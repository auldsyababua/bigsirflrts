# Story 4.4: List Sharing & Permissions

## Overview

Implement comprehensive list sharing capabilities with granular permission controls, enabling teams to collaborate on shared checklists, delegate tasks, and maintain accountability through role-based access control.

## Context

- **Epic**: Epic 4 - Lists Management
- **Priority**: P2 (Essential for team collaboration)
- **Dependencies**:
  - Story 4.1 (Lists Interface) - COMPLETED
  - Story 4.2 (List Management Commands) - COMPLETED
  - Story 2.6 (Telegram User Context) - Required for user identification
- **Blocks**: Story 4.5 (Notifications depend on sharing events)

## Technical Requirements

### Core Permission Architecture

```typescript
// Permission and sharing models
interface ListPermission {
  id: string;
  listId: string;
  grantedTo: PermissionTarget;
  grantedBy: string;
  permissionLevel: PermissionLevel;
  capabilities: Capability[];
  constraints: PermissionConstraints;
  expiresAt?: Date;
  createdAt: Date;
  lastAccessedAt?: Date;
}

enum PermissionLevel {
  OWNER = 'owner',           // Full control, can delete list
  ADMIN = 'admin',           // Can edit, share, manage permissions
  EDITOR = 'editor',         // Can edit items, mark complete
  CONTRIBUTOR = 'contributor', // Can add items, update own items
  VIEWER = 'viewer',         // Read-only access
  COMMENTER = 'commenter'    // Can view and add comments only
}

interface PermissionTarget {
  type: 'user' | 'team' | 'role' | 'department' | 'public_link';
  id: string;
  metadata?: {
    name?: string;
    email?: string;
    telegramId?: string;
    department?: string;
  };
}

interface Capability {
  action: 'read' | 'write' | 'delete' | 'share' | 'manage_permissions' | 'export' | 'archive';
  resource: 'list' | 'items' | 'comments' | 'attachments' | 'metadata';
  conditions?: CapabilityCondition[];
}

interface PermissionConstraints {
  maxShares?: number;
  allowReshare: boolean;
  requireApproval: boolean;
  visibleFields?: string[];
  hiddenItems?: string[];
  timeRestriction?: TimeRestriction;
  locationRestriction?: LocationRestriction;
}

interface ShareInvitation {
  id: string;
  listId: string;
  invitedBy: string;
  invitedUser?: string;
  inviteEmail?: string;
  invitePhone?: string;
  permissionLevel: PermissionLevel;
  message?: string;
  token: string;
  expiresAt: Date;
  acceptedAt?: Date;
  declinedAt?: Date;
  createdAt: Date;
}
```

### PostgreSQL Permission Schema

```sql
-- List sharing permissions
CREATE TABLE list_permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  list_id UUID NOT NULL REFERENCES user_lists(id) ON DELETE CASCADE,
  granted_to_type VARCHAR(20) NOT NULL,
  granted_to_id VARCHAR(255) NOT NULL,
  granted_by UUID NOT NULL REFERENCES personnel(id),
  permission_level VARCHAR(20) NOT NULL,
  capabilities JSONB DEFAULT '[]',
  constraints JSONB DEFAULT '{}',
  expires_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  last_accessed_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  revoked_by UUID REFERENCES personnel(id),
  revoke_reason TEXT,
  CONSTRAINT unique_permission_per_target
    UNIQUE(list_id, granted_to_type, granted_to_id)
    WHERE revoked_at IS NULL
);

-- Share invitations tracking
CREATE TABLE share_invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  list_id UUID NOT NULL REFERENCES user_lists(id) ON DELETE CASCADE,
  invited_by UUID NOT NULL REFERENCES personnel(id),
  invited_user UUID REFERENCES personnel(id),
  invite_email VARCHAR(255),
  invite_phone VARCHAR(50),
  invite_telegram_id VARCHAR(100),
  permission_level VARCHAR(20) NOT NULL,
  message TEXT,
  token VARCHAR(255) UNIQUE NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL DEFAULT NOW() + INTERVAL '7 days',
  accepted_at TIMESTAMPTZ,
  declined_at TIMESTAMPTZ,
  reminder_sent_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT invite_has_recipient
    CHECK (invited_user IS NOT NULL OR invite_email IS NOT NULL OR
           invite_phone IS NOT NULL OR invite_telegram_id IS NOT NULL)
);

-- Team/group memberships for bulk sharing
CREATE TABLE sharing_groups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  organization_id UUID NOT NULL REFERENCES organizations(id),
  created_by UUID NOT NULL REFERENCES personnel(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true
);

CREATE TABLE sharing_group_members (
  group_id UUID NOT NULL REFERENCES sharing_groups(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES personnel(id) ON DELETE CASCADE,
  added_by UUID NOT NULL REFERENCES personnel(id),
  added_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (group_id, user_id)
);

-- Audit log for permission changes
CREATE TABLE permission_audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  list_id UUID NOT NULL,
  action VARCHAR(50) NOT NULL,
  actor_id UUID NOT NULL,
  target_type VARCHAR(20),
  target_id VARCHAR(255),
  previous_permission JSONB,
  new_permission JSONB,
  reason TEXT,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Row-level security policies
ALTER TABLE user_lists ENABLE ROW LEVEL SECURITY;

CREATE POLICY list_access_policy ON user_lists
  FOR ALL
  USING (
    created_by = current_user_id()
    OR EXISTS (
      SELECT 1 FROM list_permissions
      WHERE list_id = user_lists.id
        AND granted_to_id = current_user_id()
        AND revoked_at IS NULL
        AND (expires_at IS NULL OR expires_at > NOW())
    )
  );

-- Indexes for permission queries
CREATE INDEX idx_permissions_list ON list_permissions(list_id) WHERE revoked_at IS NULL;
CREATE INDEX idx_permissions_user ON list_permissions(granted_to_id) WHERE granted_to_type = 'user' AND revoked_at IS NULL;
CREATE INDEX idx_permissions_expiry ON list_permissions(expires_at) WHERE expires_at IS NOT NULL AND revoked_at IS NULL;
CREATE INDEX idx_invitations_token ON share_invitations(token) WHERE accepted_at IS NULL AND declined_at IS NULL;
CREATE INDEX idx_audit_log_list ON permission_audit_log(list_id, created_at DESC);
```

### Permission Management Service

```typescript
import { SupabaseClient } from '@supabase/supabase-js';
import { createHash, randomBytes } from 'crypto';
import { z } from 'zod';

class PermissionManagementService {
  constructor(
    private supabase: SupabaseClient,
    private notificationService: NotificationService
  ) {}

  /**
   * Share a list with granular permissions
   */
  async shareList(
    listId: string,
    sharedBy: string,
    shareConfig: ShareConfiguration
  ): Promise<ShareResult> {
    // Validate sharing permissions
    const canShare = await this.canUserShare(listId, sharedBy);
    if (!canShare) {
      throw new ForbiddenError('You do not have permission to share this list');
    }

    // Check sharing limits
    const sharingLimits = await this.checkSharingLimits(listId, sharedBy);
    if (sharingLimits.exceeded) {
      throw new LimitExceededError(sharingLimits.message);
    }

    // Process different share types
    const results: ShareResult[] = [];

    if (shareConfig.users?.length) {
      results.push(...await this.shareWithUsers(listId, sharedBy, shareConfig.users));
    }

    if (shareConfig.teams?.length) {
      results.push(...await this.shareWithTeams(listId, sharedBy, shareConfig.teams));
    }

    if (shareConfig.publicLink) {
      results.push(await this.createPublicLink(listId, sharedBy, shareConfig.publicLink));
    }

    // Send notifications
    await this.sendShareNotifications(results, shareConfig.message);

    // Audit log
    await this.auditShareAction(listId, sharedBy, results);

    return {
      success: true,
      shares: results,
      invitationLinks: results.map(r => r.invitationLink).filter(Boolean)
    };
  }

  /**
   * Advanced permission management with inheritance
   */
  async updatePermissions(
    listId: string,
    updatedBy: string,
    updates: PermissionUpdate[]
  ): Promise<void> {
    // Verify admin permissions
    const isAdmin = await this.hasPermission(listId, updatedBy, 'manage_permissions');
    if (!isAdmin) {
      throw new ForbiddenError('You do not have permission to manage permissions');
    }

    // Begin transaction
    const { data, error } = await this.supabase.rpc('update_list_permissions', {
      list_id: listId,
      updates: updates.map(u => ({
        target_type: u.targetType,
        target_id: u.targetId,
        permission_level: u.permissionLevel,
        capabilities: u.capabilities,
        constraints: u.constraints,
        expires_at: u.expiresAt
      })),
      updated_by: updatedBy
    });

    if (error) throw error;

    // Notify affected users
    await this.notifyPermissionChanges(listId, updates);
  }

  /**
   * Smart sharing suggestions based on collaboration patterns
   */
  async getSharingRecommendations(
    listId: string,
    userId: string
  ): Promise<SharingRecommendation[]> {
    // Analyze collaboration patterns
    const { data: patterns } = await this.supabase.rpc(
      'analyze_collaboration_patterns',
      {
        user_id: userId,
        list_id: listId,
        lookback_days: 30
      }
    );

    // Get frequently collaborated users
    const frequentCollaborators = patterns.frequent_collaborators || [];

    // Get users with similar roles
    const similarRoleUsers = await this.getUsersWithSimilarRoles(userId);

    // Get team members
    const teamMembers = await this.getTeamMembers(userId);

    // Combine and rank recommendations
    const recommendations = this.rankRecommendations([
      ...frequentCollaborators.map(c => ({
        ...c,
        reason: 'Frequently collaborate',
        score: c.collaboration_count * 2
      })),
      ...similarRoleUsers.map(u => ({
        ...u,
        reason: 'Similar role',
        score: 1
      })),
      ...teamMembers.map(t => ({
        ...t,
        reason: 'Team member',
        score: 1.5
      }))
    ]);

    return recommendations.slice(0, 10);
  }

  /**
   * Implement delegation with approval workflow
   */
  async delegateWithApproval(
    listId: string,
    delegatedBy: string,
    delegateTo: string,
    delegationConfig: DelegationConfig
  ): Promise<DelegationRequest> {
    // Create delegation request
    const request = {
      id: this.generateId(),
      listId,
      delegatedBy,
      delegateTo,
      permissions: delegationConfig.permissions,
      duration: delegationConfig.duration,
      reason: delegationConfig.reason,
      requiresApproval: delegationConfig.requiresApproval,
      status: delegationConfig.requiresApproval ? 'pending' : 'approved',
      createdAt: new Date()
    };

    // Store delegation request
    const { data, error } = await this.supabase
      .from('delegation_requests')
      .insert(request)
      .select()
      .single();

    if (error) throw error;

    if (delegationConfig.requiresApproval) {
      // Send approval request
      await this.sendApprovalRequest(data);
    } else {
      // Auto-approve and grant permissions
      await this.grantDelegatedPermissions(data);
    }

    return data;
  }

  /**
   * Create shareable link with security
   */
  async createShareableLink(
    listId: string,
    createdBy: string,
    linkConfig: ShareableLinkConfig
  ): Promise<ShareableLink> {
    // Generate secure token
    const token = this.generateSecureToken();
    const shortCode = this.generateShortCode();

    // Create shareable link record
    const { data: link } = await this.supabase
      .from('shareable_links')
      .insert({
        list_id: listId,
        created_by: createdBy,
        token,
        short_code: shortCode,
        permission_level: linkConfig.permissionLevel || 'viewer',
        max_uses: linkConfig.maxUses,
        expires_at: linkConfig.expiresAt,
        password_hash: linkConfig.password
          ? await this.hashPassword(linkConfig.password)
          : null,
        require_login: linkConfig.requireLogin || false,
        metadata: {
          allowed_domains: linkConfig.allowedDomains,
          allowed_ips: linkConfig.allowedIPs,
          tracking_enabled: linkConfig.enableTracking
        }
      })
      .select()
      .single();

    // Generate URLs
    const baseUrl = process.env.APP_BASE_URL;
    const fullUrl = `${baseUrl}/shared/${token}`;
    const shortUrl = `${baseUrl}/s/${shortCode}`;

    return {
      ...link,
      fullUrl,
      shortUrl,
      qrCode: await this.generateQRCode(shortUrl)
    };
  }

  /**
   * Check and enforce permission constraints
   */
  private async enforcePermissionConstraints(
    permission: ListPermission,
    context: AccessContext
  ): Promise<boolean> {
    const constraints = permission.constraints;

    // Time-based restrictions
    if (constraints.timeRestriction) {
      const now = new Date();
      const currentTime = now.getHours() * 60 + now.getMinutes();
      const { startTime, endTime } = constraints.timeRestriction;

      if (currentTime < startTime || currentTime > endTime) {
        throw new AccessDeniedError('Access not allowed at this time');
      }
    }

    // Location-based restrictions
    if (constraints.locationRestriction) {
      const userLocation = context.location;
      if (!this.isLocationAllowed(userLocation, constraints.locationRestriction)) {
        throw new AccessDeniedError('Access not allowed from this location');
      }
    }

    // IP restrictions
    if (constraints.allowedIPs?.length) {
      if (!constraints.allowedIPs.includes(context.ipAddress)) {
        throw new AccessDeniedError('Access not allowed from this IP address');
      }
    }

    return true;
  }

  /**
   * Generate secure sharing token
   */
  private generateSecureToken(): string {
    return randomBytes(32).toString('base64url');
  }

  private generateShortCode(): string {
    return randomBytes(4).toString('hex');
  }

  private async hashPassword(password: string): Promise<string> {
    const salt = randomBytes(16).toString('hex');
    const hash = createHash('sha256')
      .update(password + salt)
      .digest('hex');
    return `${salt}:${hash}`;
  }
}
```

### Telegram Sharing Interface

```typescript
import { Context, InlineKeyboard } from 'grammy';

class TelegramSharingHandler {
  /**
   * Handle sharing commands
   */
  async handleShareCommand(ctx: Context): Promise<void> {
    const command = ctx.message?.text?.split(' ')[0];
    const args = ctx.message?.text?.split(' ').slice(1);

    switch (command) {
      case '/share':
        await this.initiateSharing(ctx, args);
        break;
      case '/shared_with_me':
        await this.showSharedLists(ctx);
        break;
      case '/manage_sharing':
        await this.showSharingManagement(ctx, args);
        break;
      case '/accept_share':
        await this.acceptShareInvitation(ctx, args);
        break;
    }
  }

  /**
   * Interactive sharing flow
   */
  private async initiateSharing(ctx: Context, args: string[]): Promise<void> {
    const listName = args.join(' ');

    if (!listName) {
      await ctx.reply(
        '📤 *Share a List*\n\n' +
        'Usage: `/share [list name]`\n\n' +
        'Example: `/share Morning Checklist`',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    // Find user's list
    const list = await this.listService.findUserList(ctx.from.id, listName);

    if (!list) {
      await ctx.reply(`List "${listName}" not found.`);
      return;
    }

    // Show sharing options
    const keyboard = new InlineKeyboard()
      .row(
        InlineKeyboard.text('👤 Share with User', `share_user:${list.id}`),
        InlineKeyboard.text('👥 Share with Team', `share_team:${list.id}`)
      )
      .row(
        InlineKeyboard.text('🔗 Create Link', `share_link:${list.id}`),
        InlineKeyboard.text('📧 Share via Email', `share_email:${list.id}`)
      )
      .row(
        InlineKeyboard.text('⚙️ Advanced Options', `share_advanced:${list.id}`),
        InlineKeyboard.text('❌ Cancel', 'share_cancel')
      );

    await ctx.reply(
      `📋 *Share "${list.name}"*\n\n` +
      `Current shares: ${list.shareCount || 0}\n` +
      `Your role: ${list.userRole || 'Owner'}\n\n` +
      `How would you like to share this list?`,
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * User selection for sharing
   */
  async selectUserForSharing(ctx: Context, listId: string): Promise<void> {
    // Get sharing recommendations
    const recommendations = await this.permissionService.getSharingRecommendations(
      listId,
      ctx.from.id
    );

    const keyboard = new InlineKeyboard();

    // Add recommended users
    recommendations.slice(0, 5).forEach(rec => {
      keyboard.row(
        InlineKeyboard.text(
          `${rec.name} (${rec.reason})`,
          `share_to_user:${listId}:${rec.userId}`
        )
      );
    });

    keyboard.row(
      InlineKeyboard.text('🔍 Search User', `share_search:${listId}`),
      InlineKeyboard.text('📝 Enter Username', `share_username:${listId}`)
    );

    keyboard.row(
      InlineKeyboard.text('← Back', `share_back:${listId}`)
    );

    await ctx.editMessageText(
      '👤 *Share with User*\n\n' +
      'Select a user or search:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Permission level selection
   */
  async selectPermissionLevel(
    ctx: Context,
    listId: string,
    targetUser: string
  ): Promise<void> {
    const permissionLevels = [
      { level: 'viewer', emoji: '👁', desc: 'Can view only' },
      { level: 'commenter', emoji: '💬', desc: 'Can view and comment' },
      { level: 'contributor', emoji: '✏️', desc: 'Can add items' },
      { level: 'editor', emoji: '📝', desc: 'Can edit everything' },
      { level: 'admin', emoji: '⚙️', desc: 'Can manage permissions' }
    ];

    const keyboard = new InlineKeyboard();

    permissionLevels.forEach(perm => {
      keyboard.row(
        InlineKeyboard.text(
          `${perm.emoji} ${perm.level.charAt(0).toUpperCase() + perm.level.slice(1)} - ${perm.desc}`,
          `grant_perm:${listId}:${targetUser}:${perm.level}`
        )
      );
    });

    keyboard.row(
      InlineKeyboard.text('🔐 Custom Permissions', `custom_perm:${listId}:${targetUser}`),
      InlineKeyboard.text('← Back', `share_back:${listId}`)
    );

    await ctx.editMessageText(
      '🔐 *Select Permission Level*\n\n' +
      'Choose what this user can do:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Show lists shared with user
   */
  private async showSharedLists(ctx: Context): Promise<void> {
    const sharedLists = await this.listService.getSharedWithUser(ctx.from.id);

    if (sharedLists.length === 0) {
      await ctx.reply('No lists have been shared with you yet.');
      return;
    }

    const keyboard = new InlineKeyboard();

    sharedLists.forEach(list => {
      const permIcon = this.getPermissionIcon(list.permissionLevel);
      keyboard.row(
        InlineKeyboard.text(
          `${permIcon} ${list.name} (by ${list.sharedBy})`,
          `view_shared:${list.id}`
        )
      );
    });

    await ctx.reply(
      `📥 *Lists Shared With You* (${sharedLists.length})\n\n` +
      'Select a list to view:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Manage sharing settings
   */
  async showSharingManagement(ctx: Context, listId: string): Promise<void> {
    const permissions = await this.permissionService.getListPermissions(listId);

    const message = this.formatPermissionsList(permissions);

    const keyboard = new InlineKeyboard()
      .row(
        InlineKeyboard.text('➕ Add Share', `share_add:${listId}`),
        InlineKeyboard.text('✏️ Edit Permissions', `share_edit:${listId}`)
      )
      .row(
        InlineKeyboard.text('🔗 Manage Links', `share_links:${listId}`),
        InlineKeyboard.text('📊 Share Analytics', `share_stats:${listId}`)
      )
      .row(
        InlineKeyboard.text('🚫 Revoke All', `share_revoke_all:${listId}`),
        InlineKeyboard.text('← Back', 'share_back')
      );

    await ctx.reply(message, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  /**
   * Format permissions for display
   */
  private formatPermissionsList(permissions: ListPermission[]): string {
    if (permissions.length === 0) {
      return '🔐 *Sharing Settings*\n\nThis list is not shared with anyone.';
    }

    let message = `🔐 *Sharing Settings*\n\n`;
    message += `Total shares: ${permissions.length}\n\n`;

    const grouped = this.groupPermissionsByLevel(permissions);

    Object.entries(grouped).forEach(([level, perms]) => {
      const icon = this.getPermissionIcon(level);
      message += `${icon} *${level.toUpperCase()}* (${perms.length})\n`;

      perms.slice(0, 3).forEach(p => {
        const name = p.grantedTo.metadata?.name || p.grantedTo.id;
        const expires = p.expiresAt
          ? ` • Expires ${this.formatDate(p.expiresAt)}`
          : '';
        message += `  • ${name}${expires}\n`;
      });

      if (perms.length > 3) {
        message += `  • ...and ${perms.length - 3} more\n`;
      }
      message += '\n';
    });

    return message;
  }

  private getPermissionIcon(level: string): string {
    const icons = {
      owner: '👑',
      admin: '⚙️',
      editor: '📝',
      contributor: '✏️',
      viewer: '👁',
      commenter: '💬'
    };
    return icons[level] || '👤';
  }

  private groupPermissionsByLevel(
    permissions: ListPermission[]
  ): Record<string, ListPermission[]> {
    return permissions.reduce((acc, perm) => {
      const level = perm.permissionLevel;
      if (!acc[level]) acc[level] = [];
      acc[level].push(perm);
      return acc;
    }, {});
  }
}
```

### Advanced Permission Features

```typescript
// Hierarchical permission inheritance
class HierarchicalPermissionSystem {
  /**
   * Calculate effective permissions with inheritance
   */
  calculateEffectivePermissions(
    user: User,
    list: List,
    context: AccessContext
  ): EffectivePermissions {
    const permissions: Permission[] = [];

    // Direct user permissions
    permissions.push(...this.getUserPermissions(user.id, list.id));

    // Team permissions
    const teams = this.getUserTeams(user.id);
    teams.forEach(team => {
      permissions.push(...this.getTeamPermissions(team.id, list.id));
    });

    // Role-based permissions
    const roles = this.getUserRoles(user.id);
    roles.forEach(role => {
      permissions.push(...this.getRolePermissions(role.id, list.id));
    });

    // Department permissions
    if (user.departmentId) {
      permissions.push(...this.getDepartmentPermissions(user.departmentId, list.id));
    }

    // Resolve conflicts and calculate effective permissions
    return this.resolvePermissionConflicts(permissions, context);
  }

  /**
   * Permission conflict resolution
   */
  private resolvePermissionConflicts(
    permissions: Permission[],
    context: AccessContext
  ): EffectivePermissions {
    // Sort by priority: User > Team > Role > Department
    const sorted = permissions.sort((a, b) => {
      const priority = { user: 4, team: 3, role: 2, department: 1 };
      return priority[b.type] - priority[a.type];
    });

    // Most permissive wins (configurable)
    const strategy = context.conflictResolution || 'most_permissive';

    if (strategy === 'most_permissive') {
      return this.getMostPermissive(sorted);
    } else if (strategy === 'most_restrictive') {
      return this.getMostRestrictive(sorted);
    } else {
      return this.getFirstMatch(sorted);
    }
  }
}

// Delegation chain tracking
class DelegationChainTracker {
  /**
   * Track delegation chains for accountability
   */
  async trackDelegation(
    originalOwner: string,
    delegatedTo: string,
    listId: string,
    depth: number = 0
  ): Promise<DelegationChain> {
    const maxDepth = 3; // Prevent infinite delegation chains

    if (depth >= maxDepth) {
      throw new Error('Maximum delegation depth exceeded');
    }

    const chain = {
      id: this.generateId(),
      listId,
      originalOwner,
      currentHolder: delegatedTo,
      delegationPath: [],
      depth,
      createdAt: new Date()
    };

    // Build delegation path
    const path = await this.buildDelegationPath(listId, originalOwner, delegatedTo);
    chain.delegationPath = path;

    // Store chain record
    await this.storeDelegationChain(chain);

    // Set up monitoring
    await this.setupDelegationMonitoring(chain);

    return chain;
  }

  /**
   * Monitor delegation usage
   */
  private async setupDelegationMonitoring(chain: DelegationChain): Promise<void> {
    // Set up activity tracking
    await this.activityMonitor.track({
      chainId: chain.id,
      monitoredUser: chain.currentHolder,
      alertOriginalOwner: true,
      alertOnUnusualActivity: true,
      maxActionsPerHour: 50
    });

    // Set up expiry monitoring
    if (chain.expiresAt) {
      await this.scheduleExpiryCheck(chain);
    }
  }
}
```

### n8n Permission Workflow

```json
{
  "name": "List Sharing Workflow",
  "nodes": [
    {
      "type": "n8n-nodes-base.webhook",
      "name": "Share Request",
      "parameters": {
        "path": "share-list",
        "responseMode": "lastNode"
      }
    },
    {
      "type": "n8n-nodes-base.function",
      "name": "Validate Permissions",
      "parameters": {
        "functionCode": `
          const { listId, sharedBy, shareWith, permissionLevel } = $input.item.json;

          // Check if user can share
          const canShare = await checkUserPermission(sharedBy, listId, 'share');

          if (!canShare) {
            throw new Error('User does not have permission to share this list');
          }

          // Validate target users exist
          const validTargets = [];
          for (const target of shareWith) {
            const user = await findUser(target);
            if (user) {
              validTargets.push(user);
            }
          }

          // Check for circular sharing
          const circular = await detectCircularSharing(listId, validTargets);
          if (circular) {
            throw new Error('Circular sharing detected');
          }

          return {
            json: {
              listId,
              sharedBy,
              validTargets,
              permissionLevel,
              validated: true
            }
          };
        `
      }
    },
    {
      "type": "n8n-nodes-base.postgres",
      "name": "Create Permissions",
      "parameters": {
        "operation": "executeQuery",
        "query": `
          INSERT INTO list_permissions (
            list_id,
            granted_to_type,
            granted_to_id,
            granted_by,
            permission_level,
            capabilities,
            created_at
          )
          SELECT
            $1 as list_id,
            'user' as granted_to_type,
            unnest($2::uuid[]) as granted_to_id,
            $3 as granted_by,
            $4 as permission_level,
            $5 as capabilities,
            NOW() as created_at
          ON CONFLICT (list_id, granted_to_type, granted_to_id)
          WHERE revoked_at IS NULL
          DO UPDATE SET
            permission_level = EXCLUDED.permission_level,
            capabilities = EXCLUDED.capabilities,
            updated_at = NOW()
          RETURNING *
        `,
        "additionalFields": {
          "queryParams": "={{$json.queryParams}}"
        }
      }
    },
    {
      "type": "n8n-nodes-base.telegram",
      "name": "Send Notifications",
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{$json.telegramChatId}}",
        "text": `
📋 *List Shared With You*

{{$json.sharedByName}} has shared "{{$json.listName}}" with you.

Permission: {{$json.permissionLevel}}
{{#if $json.message}}
Message: {{$json.message}}
{{/if}}

[Accept Share]({{$json.acceptLink}})
[View List]({{$json.viewLink}})
        `,
        "additionalFields": {
          "parse_mode": "Markdown",
          "disable_web_page_preview": true
        }
      }
    }
  ]
}
```

## Implementation Checklist

### Phase 1: Database Setup

- [ ] Create permission tables with constraints
- [ ] Implement RLS policies
- [ ] Set up audit logging
- [ ] Add sharing group tables

### Phase 2: Core Permission Logic

- [ ] Build PermissionManagementService
- [ ] Implement permission inheritance
- [ ] Add conflict resolution
- [ ] Create delegation tracking

### Phase 3: Telegram Integration

- [ ] Add sharing commands
- [ ] Build interactive sharing flow
- [ ] Implement permission management UI
- [ ] Add invitation acceptance flow

### Phase 4: Advanced Features

- [ ] Implement shareable links
- [ ] Add approval workflows
- [ ] Build analytics dashboard
- [ ] Create bulk sharing operations

## Testing Requirements

```typescript
describe('Permission System', () => {
  describe('Sharing Operations', () => {
    it('should enforce permission hierarchy', async () => {
      const owner = 'owner-id';
      const editor = 'editor-id';
      const viewer = 'viewer-id';

      // Owner shares with editor
      await permissionService.shareList(listId, owner, {
        users: [{ id: editor, level: 'editor' }]
      });

      // Editor tries to share with viewer (should succeed)
      await permissionService.shareList(listId, editor, {
        users: [{ id: viewer, level: 'viewer' }]
      });

      // Viewer tries to share (should fail)
      await expect(
        permissionService.shareList(listId, viewer, {
          users: [{ id: 'another-user', level: 'viewer' }]
        })
      ).rejects.toThrow(ForbiddenError);
    });

    it('should prevent circular sharing', async () => {
      // A shares with B
      await permissionService.shareList(listA, userA, {
        users: [{ id: userB, level: 'admin' }]
      });

      // B shares their list with A
      await permissionService.shareList(listB, userB, {
        users: [{ id: userA, level: 'admin' }]
      });

      // Attempting to create circular dependency should fail
      const circular = await permissionService.detectCircularSharing(
        [listA, listB]
      );
      expect(circular).toBe(true);
    });

    it('should respect time-based constraints', async () => {
      const permission = await permissionService.createTemporaryShare(
        listId,
        userId,
        {
          duration: '24h',
          level: 'editor'
        }
      );

      // Access should work immediately
      expect(await permissionService.hasAccess(listId, userId)).toBe(true);

      // Fast-forward 25 hours
      jest.advanceTimersByTime(25 * 60 * 60 * 1000);

      // Access should be revoked
      expect(await permissionService.hasAccess(listId, userId)).toBe(false);
    });
  });
});
```

## Performance Specifications

- Permission check: < 10ms for direct permissions
- Inheritance calculation: < 50ms for complex hierarchies
- Bulk sharing: 100+ users in < 1 second
- Share link generation: < 20ms
- Permission updates: < 100ms with notifications

## Security Requirements

- Enforce principle of least privilege
- Audit all permission changes
- Validate all sharing targets
- Implement rate limiting for shares (50/day/user)
- Encrypt shareable link tokens
- Require 2FA for owner permission changes
- Auto-revoke unused permissions after 90 days

## Developer Resources

### Essential Documentation

```bash
# PostgreSQL RLS best practices
mcp__ref__ref_search_documentation "PostgreSQL row level security sharing permissions"

# OAuth 2.0 permission models
mcp__ref__ref_search_documentation "OAuth 2.0 granular permission scopes"

# Telegram bot user management
mcp__ref__ref_search_documentation "Telegram bot multi-user permission management"
```

### Debugging Commands

```sql
-- Check user's effective permissions
WITH RECURSIVE permission_chain AS (
  SELECT * FROM list_permissions
  WHERE granted_to_id = 'user-id' AND list_id = 'list-id'
  UNION ALL
  SELECT p.* FROM list_permissions p
  JOIN sharing_group_members sgm ON p.granted_to_id = sgm.group_id::text
  WHERE sgm.user_id = 'user-id'
)
SELECT DISTINCT ON (list_id)
  list_id,
  permission_level,
  array_agg(DISTINCT granted_to_type) as sources
FROM permission_chain
GROUP BY list_id, permission_level
ORDER BY list_id,
  CASE permission_level
    WHEN 'owner' THEN 1
    WHEN 'admin' THEN 2
    WHEN 'editor' THEN 3
    WHEN 'viewer' THEN 4
  END;

-- Audit trail for list
SELECT
  action,
  actor_id,
  target_type,
  target_id,
  created_at
FROM permission_audit_log
WHERE list_id = 'list-id'
ORDER BY created_at DESC
LIMIT 20;
```

## Acceptance Criteria

1. ✅ Users can share lists with granular permissions
2. ✅ Permission inheritance works correctly
3. ✅ Shareable links can be created with constraints
4. ✅ Telegram interface provides easy sharing flow
5. ✅ Audit trail tracks all permission changes
6. ✅ Performance meets specifications under load

## Notes for Developers

- Cache permission checks for performance
- Use database transactions for permission updates
- Implement soft deletes for audit trail
- Consider GDPR compliance for sharing data
- Plan for permission migration tools
- Document permission precedence clearly
