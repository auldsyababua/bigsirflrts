# Story 4.4: List Sharing & Permissions

## Overview

Implement comprehensive list sharing capabilities with granular permission controls, enabling teams to collaborate on shared checklists, delegate tasks, and maintain accountability through role-based access control.

## Context

- **Epic**: Epic 4 - Lists Management
- **Priority**: P2 (Essential for team collaboration)
- **Dependencies**:
  - Story 4.1 (Lists Interface) - COMPLETED
  - Story 4.2 (List Management Commands) - COMPLETED
  - Story 2.6 (Telegram User Context) - Required for user identification
- **Blocks**: Story 4.5 (Notifications depend on sharing events)

## Technical Requirements

### Core Permission Architecture

```typescript
// Permission and sharing models
interface ListPermission {
  id: string;
  listId: string;
  grantedTo: PermissionTarget;
  grantedBy: string;
  permissionLevel: PermissionLevel;
  capabilities: Capability[];
  constraints: PermissionConstraints;
  expiresAt?: Date;
  createdAt: Date;
  lastAccessedAt?: Date;
}

enum PermissionLevel {
  OWNER = 'owner',           // Full control, can delete list
  ADMIN = 'admin',           // Can edit, share, manage permissions
  EDITOR = 'editor',         // Can edit items, mark complete
  CONTRIBUTOR = 'contributor', // Can add items, update own items
  VIEWER = 'viewer',         // Read-only access
  COMMENTER = 'commenter'    // Can view and add comments only
}

interface PermissionTarget {
  type: 'user' | 'team' | 'role' | 'department' | 'public_link';
  id: string;
  metadata?: {
    name?: string;
    email?: string;
    telegramId?: string;
    department?: string;
  };
}

interface Capability {
  action: 'read' | 'write' | 'delete' | 'share' | 'manage_permissions' | 'export' | 'archive';
  resource: 'list' | 'items' | 'comments' | 'attachments' | 'metadata';
  conditions?: CapabilityCondition[];
}

interface PermissionConstraints {
  maxShares?: number;
  allowReshare: boolean;
  requireApproval: boolean;
  visibleFields?: string[];
  hiddenItems?: string[];
  timeRestriction?: TimeRestriction;
  locationRestriction?: LocationRestriction;
}

interface ShareInvitation {
  id: string;
  listId: string;
  invitedBy: string;
  invitedUser?: string;
  inviteEmail?: string;
  invitePhone?: string;
  permissionLevel: PermissionLevel;
  message?: string;
  token: string;
  expiresAt: Date;
  acceptedAt?: Date;
  declinedAt?: Date;
  createdAt: Date;
}
```

### PostgreSQL Permission Schema

```sql
-- List sharing permissions
CREATE TABLE list_permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  list_id UUID NOT NULL REFERENCES user_lists(id) ON DELETE CASCADE,
  granted_to_type VARCHAR(20) NOT NULL,
  granted_to_id VARCHAR(255) NOT NULL,
  granted_by UUID NOT NULL REFERENCES personnel(id),
  permission_level VARCHAR(20) NOT NULL,
  capabilities JSONB DEFAULT '[]',
  constraints JSONB DEFAULT '{}',
  expires_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  last_accessed_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  revoked_by UUID REFERENCES personnel(id),
  revoke_reason TEXT,
  CONSTRAINT unique_permission_per_target
    UNIQUE(list_id, granted_to_type, granted_to_id)
    WHERE revoked_at IS NULL
);

-- Share invitations tracking
CREATE TABLE share_invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  list_id UUID NOT NULL REFERENCES user_lists(id) ON DELETE CASCADE,
  invited_by UUID NOT NULL REFERENCES personnel(id),
  invited_user UUID REFERENCES personnel(id),
  invite_email VARCHAR(255),
  invite_phone VARCHAR(50),
  invite_telegram_id VARCHAR(100),
  permission_level VARCHAR(20) NOT NULL,
  message TEXT,
  token VARCHAR(255) UNIQUE NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL DEFAULT NOW() + INTERVAL '7 days',
  accepted_at TIMESTAMPTZ,
  declined_at TIMESTAMPTZ,
  reminder_sent_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT invite_has_recipient
    CHECK (invited_user IS NOT NULL OR invite_email IS NOT NULL OR
           invite_phone IS NOT NULL OR invite_telegram_id IS NOT NULL)
);

-- Team/group memberships for bulk sharing
CREATE TABLE sharing_groups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  organization_id UUID NOT NULL REFERENCES organizations(id),
  created_by UUID NOT NULL REFERENCES personnel(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true
);

CREATE TABLE sharing_group_members (
  group_id UUID NOT NULL REFERENCES sharing_groups(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES personnel(id) ON DELETE CASCADE,
  added_by UUID NOT NULL REFERENCES personnel(id),
  added_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (group_id, user_id)
);

-- Audit log for permission changes
CREATE TABLE permission_audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  list_id UUID NOT NULL,
  action VARCHAR(50) NOT NULL,
  actor_id UUID NOT NULL,
  target_type VARCHAR(20),
  target_id VARCHAR(255),
  previous_permission JSONB,
  new_permission JSONB,
  reason TEXT,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Row-level security policies
ALTER TABLE user_lists ENABLE ROW LEVEL SECURITY;

CREATE POLICY list_access_policy ON user_lists
  FOR ALL
  USING (
    created_by = current_user_id()
    OR EXISTS (
      SELECT 1 FROM list_permissions
      WHERE list_id = user_lists.id
        AND granted_to_id = current_user_id()
        AND revoked_at IS NULL
        AND (expires_at IS NULL OR expires_at > NOW())
    )
  );

-- Indexes for permission queries
CREATE INDEX idx_permissions_list ON list_permissions(list_id) WHERE revoked_at IS NULL;
CREATE INDEX idx_permissions_user ON list_permissions(granted_to_id) WHERE granted_to_type = 'user' AND revoked_at IS NULL;
CREATE INDEX idx_permissions_expiry ON list_permissions(expires_at) WHERE expires_at IS NOT NULL AND revoked_at IS NULL;
CREATE INDEX idx_invitations_token ON share_invitations(token) WHERE accepted_at IS NULL AND declined_at IS NULL;
CREATE INDEX idx_audit_log_list ON permission_audit_log(list_id, created_at DESC);
```

### Permission Management Service

```typescript
import { SupabaseClient } from '@supabase/supabase-js';
import { createHash, randomBytes } from 'crypto';
import { z } from 'zod';

class PermissionManagementService {
  constructor(
    private supabase: SupabaseClient,
    private notificationService: NotificationService
  ) {}

  /**
   * Share a list with granular permissions
   */
  async shareList(
    listId: string,
    sharedBy: string,
    shareConfig: ShareConfiguration
  ): Promise<ShareResult> {
    // Validate sharing permissions
    const canShare = await this.canUserShare(listId, sharedBy);
    if (!canShare) {
      throw new ForbiddenError('You do not have permission to share this list');
    }

    // Check sharing limits
    const sharingLimits = await this.checkSharingLimits(listId, sharedBy);
    if (sharingLimits.exceeded) {
      throw new LimitExceededError(sharingLimits.message);
    }

    // Process different share types
    const results: ShareResult[] = [];

    if (shareConfig.users?.length) {
      results.push(...await this.shareWithUsers(listId, sharedBy, shareConfig.users));
    }

    if (shareConfig.teams?.length) {
      results.push(...await this.shareWithTeams(listId, sharedBy, shareConfig.teams));
    }

    if (shareConfig.publicLink) {
      results.push(await this.createPublicLink(listId, sharedBy, shareConfig.publicLink));
    }

    // Send notifications
    await this.sendShareNotifications(results, shareConfig.message);

    // Audit log
    await this.auditShareAction(listId, sharedBy, results);

    return {
      success: true,
      shares: results,
      invitationLinks: results.map(r => r.invitationLink).filter(Boolean)
    };
  }

  /**
   * Advanced permission management with inheritance
   */
  async updatePermissions(
    listId: string,
    updatedBy: string,
    updates: PermissionUpdate[]
  ): Promise<void> {
    // Verify admin permissions
    const isAdmin = await this.hasPermission(listId, updatedBy, 'manage_permissions');
    if (!isAdmin) {
      throw new ForbiddenError('You do not have permission to manage permissions');
    }

    // Begin transaction
    const { data, error } = await this.supabase.rpc('update_list_permissions', {
      list_id: listId,
      updates: updates.map(u => ({
        target_type: u.targetType,
        target_id: u.targetId,
        permission_level: u.permissionLevel,
        capabilities: u.capabilities,
        constraints: u.constraints,
        expires_at: u.expiresAt
      })),
      updated_by: updatedBy
    });

    if (error) throw error;

    // Notify affected users
    await this.notifyPermissionChanges(listId, updates);
  }

  /**
   * Smart sharing suggestions based on collaboration patterns
   */
  async getSharingRecommendations(
    listId: string,
    userId: string
  ): Promise<SharingRecommendation[]> {
    // Analyze collaboration patterns
    const { data: patterns } = await this.supabase.rpc(
      'analyze_collaboration_patterns',
      {
        user_id: userId,
        list_id: listId,
        lookback_days: 30
      }
    );

    // Get frequently collaborated users
    const frequentCollaborators = patterns.frequent_collaborators || [];

    // Get users with similar roles
    const similarRoleUsers = await this.getUsersWithSimilarRoles(userId);

    // Get team members
    const teamMembers = await this.getTeamMembers(userId);

    // Combine and rank recommendations
    const recommendations = this.rankRecommendations([
      ...frequentCollaborators.map(c => ({
        ...c,
        reason: 'Frequently collaborate',
        score: c.collaboration_count * 2
      })),
      ...similarRoleUsers.map(u => ({
        ...u,
        reason: 'Similar role',
        score: 1
      })),
      ...teamMembers.map(t => ({
        ...t,
        reason: 'Team member',
        score: 1.5
      }))
    ]);

    return recommendations.slice(0, 10);
  }

  /**
   * Implement delegation with approval workflow
   */
  async delegateWithApproval(
    listId: string,
    delegatedBy: string,
    delegateTo: string,
    delegationConfig: DelegationConfig
  ): Promise<DelegationRequest> {
    // Create delegation request
    const request = {
      id: this.generateId(),
      listId,
      delegatedBy,
      delegateTo,
      permissions: delegationConfig.permissions,
      duration: delegationConfig.duration,
      reason: delegationConfig.reason,
      requiresApproval: delegationConfig.requiresApproval,
      status: delegationConfig.requiresApproval ? 'pending' : 'approved',
      createdAt: new Date()
    };

    // Store delegation request
    const { data, error } = await this.supabase
      .from('delegation_requests')
      .insert(request)
      .select()
      .single();

    if (error) throw error;

    if (delegationConfig.requiresApproval) {
      // Send approval request
      await this.sendApprovalRequest(data);
    } else {
      // Auto-approve and grant permissions
      await this.grantDelegatedPermissions(data);
    }

    return data;
  }

  /**
   * Create shareable link with security
   */
  async createShareableLink(
    listId: string,
    createdBy: string,
    linkConfig: ShareableLinkConfig
  ): Promise<ShareableLink> {
    // Generate secure token
    const token = this.generateSecureToken();
    const shortCode = this.generateShortCode();

    // Create shareable link record
    const { data: link } = await this.supabase
      .from('shareable_links')
      .insert({
        list_id: listId,
        created_by: createdBy,
        token,
        short_code: shortCode,
        permission_level: linkConfig.permissionLevel || 'viewer',
        max_uses: linkConfig.maxUses,
        expires_at: linkConfig.expiresAt,
        password_hash: linkConfig.password
          ? await this.hashPassword(linkConfig.password)
          : null,
        require_login: linkConfig.requireLogin || false,
        metadata: {
          allowed_domains: linkConfig.allowedDomains,
          allowed_ips: linkConfig.allowedIPs,
          tracking_enabled: linkConfig.enableTracking
        }
      })
      .select()
      .single();

    // Generate URLs
    const baseUrl = process.env.APP_BASE_URL;
    const fullUrl = `${baseUrl}/shared/${token}`;
    const shortUrl = `${baseUrl}/s/${shortCode}`;

    return {
      ...link,
      fullUrl,
      shortUrl,
      qrCode: await this.generateQRCode(shortUrl)
    };
  }

  /**
   * Check and enforce permission constraints
   */
  private async enforcePermissionConstraints(
    permission: ListPermission,
    context: AccessContext
  ): Promise<boolean> {
    const constraints = permission.constraints;

    // Time-based restrictions
    if (constraints.timeRestriction) {
      const now = new Date();
      const currentTime = now.getHours() * 60 + now.getMinutes();
      const { startTime, endTime } = constraints.timeRestriction;

      if (currentTime < startTime || currentTime > endTime) {
        throw new AccessDeniedError('Access not allowed at this time');
      }
    }

    // Location-based restrictions
    if (constraints.locationRestriction) {
      const userLocation = context.location;
      if (!this.isLocationAllowed(userLocation, constraints.locationRestriction)) {
        throw new AccessDeniedError('Access not allowed from this location');
      }
    }

    // IP restrictions
    if (constraints.allowedIPs?.length) {
      if (!constraints.allowedIPs.includes(context.ipAddress)) {
        throw new AccessDeniedError('Access not allowed from this IP address');
      }
    }

    return true;
  }

  /**
   * Generate secure sharing token
   */
  private generateSecureToken(): string {
    return randomBytes(32).toString('base64url');
  }

  private generateShortCode(): string {
    return randomBytes(4).toString('hex');
  }

  private async hashPassword(password: string): Promise<string> {
    const salt = randomBytes(16).toString('hex');
    const hash = createHash('sha256')
      .update(password + salt)
      .digest('hex');
    return `${salt}:${hash}`;
  }
}
```

### Telegram Sharing Interface

```typescript
import { Context, InlineKeyboard } from 'grammy';

class TelegramSharingHandler {
  /**
   * Handle sharing commands
   */
  async handleShareCommand(ctx: Context): Promise<void> {
    const command = ctx.message?.text?.split(' ')[0];
    const args = ctx.message?.text?.split(' ').slice(1);

    switch (command) {
      case '/share':
        await this.initiateSharing(ctx, args);
        break;
      case '/shared_with_me':
        await this.showSharedLists(ctx);
        break;
      case '/manage_sharing':
        await this.showSharingManagement(ctx, args);
        break;
      case '/accept_share':
        await this.acceptShareInvitation(ctx, args);
        break;
    }
  }

  /**
   * Interactive sharing flow
   */
  private async initiateSharing(ctx: Context, args: string[]): Promise<void> {
    const listName = args.join(' ');

    if (!listName) {
      await ctx.reply(
        'üì§ *Share a List*\n\n' +
        'Usage: `/share [list name]`\n\n' +
        'Example: `/share Morning Checklist`',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    // Find user's list
    const list = await this.listService.findUserList(ctx.from.id, listName);

    if (!list) {
      await ctx.reply(`List "${listName}" not found.`);
      return;
    }

    // Show sharing options
    const keyboard = new InlineKeyboard()
      .row(
        InlineKeyboard.text('üë§ Share with User', `share_user:${list.id}`),
        InlineKeyboard.text('üë• Share with Team', `share_team:${list.id}`)
      )
      .row(
        InlineKeyboard.text('üîó Create Link', `share_link:${list.id}`),
        InlineKeyboard.text('üìß Share via Email', `share_email:${list.id}`)
      )
      .row(
        InlineKeyboard.text('‚öôÔ∏è Advanced Options', `share_advanced:${list.id}`),
        InlineKeyboard.text('‚ùå Cancel', 'share_cancel')
      );

    await ctx.reply(
      `üìã *Share "${list.name}"*\n\n` +
      `Current shares: ${list.shareCount || 0}\n` +
      `Your role: ${list.userRole || 'Owner'}\n\n` +
      `How would you like to share this list?`,
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * User selection for sharing
   */
  async selectUserForSharing(ctx: Context, listId: string): Promise<void> {
    // Get sharing recommendations
    const recommendations = await this.permissionService.getSharingRecommendations(
      listId,
      ctx.from.id
    );

    const keyboard = new InlineKeyboard();

    // Add recommended users
    recommendations.slice(0, 5).forEach(rec => {
      keyboard.row(
        InlineKeyboard.text(
          `${rec.name} (${rec.reason})`,
          `share_to_user:${listId}:${rec.userId}`
        )
      );
    });

    keyboard.row(
      InlineKeyboard.text('üîç Search User', `share_search:${listId}`),
      InlineKeyboard.text('üìù Enter Username', `share_username:${listId}`)
    );

    keyboard.row(
      InlineKeyboard.text('‚Üê Back', `share_back:${listId}`)
    );

    await ctx.editMessageText(
      'üë§ *Share with User*\n\n' +
      'Select a user or search:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Permission level selection
   */
  async selectPermissionLevel(
    ctx: Context,
    listId: string,
    targetUser: string
  ): Promise<void> {
    const permissionLevels = [
      { level: 'viewer', emoji: 'üëÅ', desc: 'Can view only' },
      { level: 'commenter', emoji: 'üí¨', desc: 'Can view and comment' },
      { level: 'contributor', emoji: '‚úèÔ∏è', desc: 'Can add items' },
      { level: 'editor', emoji: 'üìù', desc: 'Can edit everything' },
      { level: 'admin', emoji: '‚öôÔ∏è', desc: 'Can manage permissions' }
    ];

    const keyboard = new InlineKeyboard();

    permissionLevels.forEach(perm => {
      keyboard.row(
        InlineKeyboard.text(
          `${perm.emoji} ${perm.level.charAt(0).toUpperCase() + perm.level.slice(1)} - ${perm.desc}`,
          `grant_perm:${listId}:${targetUser}:${perm.level}`
        )
      );
    });

    keyboard.row(
      InlineKeyboard.text('üîê Custom Permissions', `custom_perm:${listId}:${targetUser}`),
      InlineKeyboard.text('‚Üê Back', `share_back:${listId}`)
    );

    await ctx.editMessageText(
      'üîê *Select Permission Level*\n\n' +
      'Choose what this user can do:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Show lists shared with user
   */
  private async showSharedLists(ctx: Context): Promise<void> {
    const sharedLists = await this.listService.getSharedWithUser(ctx.from.id);

    if (sharedLists.length === 0) {
      await ctx.reply('No lists have been shared with you yet.');
      return;
    }

    const keyboard = new InlineKeyboard();

    sharedLists.forEach(list => {
      const permIcon = this.getPermissionIcon(list.permissionLevel);
      keyboard.row(
        InlineKeyboard.text(
          `${permIcon} ${list.name} (by ${list.sharedBy})`,
          `view_shared:${list.id}`
        )
      );
    });

    await ctx.reply(
      `üì• *Lists Shared With You* (${sharedLists.length})\n\n` +
      'Select a list to view:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Manage sharing settings
   */
  async showSharingManagement(ctx: Context, listId: string): Promise<void> {
    const permissions = await this.permissionService.getListPermissions(listId);

    const message = this.formatPermissionsList(permissions);

    const keyboard = new InlineKeyboard()
      .row(
        InlineKeyboard.text('‚ûï Add Share', `share_add:${listId}`),
        InlineKeyboard.text('‚úèÔ∏è Edit Permissions', `share_edit:${listId}`)
      )
      .row(
        InlineKeyboard.text('üîó Manage Links', `share_links:${listId}`),
        InlineKeyboard.text('üìä Share Analytics', `share_stats:${listId}`)
      )
      .row(
        InlineKeyboard.text('üö´ Revoke All', `share_revoke_all:${listId}`),
        InlineKeyboard.text('‚Üê Back', 'share_back')
      );

    await ctx.reply(message, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  /**
   * Format permissions for display
   */
  private formatPermissionsList(permissions: ListPermission[]): string {
    if (permissions.length === 0) {
      return 'üîê *Sharing Settings*\n\nThis list is not shared with anyone.';
    }

    let message = `üîê *Sharing Settings*\n\n`;
    message += `Total shares: ${permissions.length}\n\n`;

    const grouped = this.groupPermissionsByLevel(permissions);

    Object.entries(grouped).forEach(([level, perms]) => {
      const icon = this.getPermissionIcon(level);
      message += `${icon} *${level.toUpperCase()}* (${perms.length})\n`;

      perms.slice(0, 3).forEach(p => {
        const name = p.grantedTo.metadata?.name || p.grantedTo.id;
        const expires = p.expiresAt
          ? ` ‚Ä¢ Expires ${this.formatDate(p.expiresAt)}`
          : '';
        message += `  ‚Ä¢ ${name}${expires}\n`;
      });

      if (perms.length > 3) {
        message += `  ‚Ä¢ ...and ${perms.length - 3} more\n`;
      }
      message += '\n';
    });

    return message;
  }

  private getPermissionIcon(level: string): string {
    const icons = {
      owner: 'üëë',
      admin: '‚öôÔ∏è',
      editor: 'üìù',
      contributor: '‚úèÔ∏è',
      viewer: 'üëÅ',
      commenter: 'üí¨'
    };
    return icons[level] || 'üë§';
  }

  private groupPermissionsByLevel(
    permissions: ListPermission[]
  ): Record<string, ListPermission[]> {
    return permissions.reduce((acc, perm) => {
      const level = perm.permissionLevel;
      if (!acc[level]) acc[level] = [];
      acc[level].push(perm);
      return acc;
    }, {});
  }
}
```

### Advanced Permission Features

```typescript
// Hierarchical permission inheritance
class HierarchicalPermissionSystem {
  /**
   * Calculate effective permissions with inheritance
   */
  calculateEffectivePermissions(
    user: User,
    list: List,
    context: AccessContext
  ): EffectivePermissions {
    const permissions: Permission[] = [];

    // Direct user permissions
    permissions.push(...this.getUserPermissions(user.id, list.id));

    // Team permissions
    const teams = this.getUserTeams(user.id);
    teams.forEach(team => {
      permissions.push(...this.getTeamPermissions(team.id, list.id));
    });

    // Role-based permissions
    const roles = this.getUserRoles(user.id);
    roles.forEach(role => {
      permissions.push(...this.getRolePermissions(role.id, list.id));
    });

    // Department permissions
    if (user.departmentId) {
      permissions.push(...this.getDepartmentPermissions(user.departmentId, list.id));
    }

    // Resolve conflicts and calculate effective permissions
    return this.resolvePermissionConflicts(permissions, context);
  }

  /**
   * Permission conflict resolution
   */
  private resolvePermissionConflicts(
    permissions: Permission[],
    context: AccessContext
  ): EffectivePermissions {
    // Sort by priority: User > Team > Role > Department
    const sorted = permissions.sort((a, b) => {
      const priority = { user: 4, team: 3, role: 2, department: 1 };
      return priority[b.type] - priority[a.type];
    });

    // Most permissive wins (configurable)
    const strategy = context.conflictResolution || 'most_permissive';

    if (strategy === 'most_permissive') {
      return this.getMostPermissive(sorted);
    } else if (strategy === 'most_restrictive') {
      return this.getMostRestrictive(sorted);
    } else {
      return this.getFirstMatch(sorted);
    }
  }
}

// Delegation chain tracking
class DelegationChainTracker {
  /**
   * Track delegation chains for accountability
   */
  async trackDelegation(
    originalOwner: string,
    delegatedTo: string,
    listId: string,
    depth: number = 0
  ): Promise<DelegationChain> {
    const maxDepth = 3; // Prevent infinite delegation chains

    if (depth >= maxDepth) {
      throw new Error('Maximum delegation depth exceeded');
    }

    const chain = {
      id: this.generateId(),
      listId,
      originalOwner,
      currentHolder: delegatedTo,
      delegationPath: [],
      depth,
      createdAt: new Date()
    };

    // Build delegation path
    const path = await this.buildDelegationPath(listId, originalOwner, delegatedTo);
    chain.delegationPath = path;

    // Store chain record
    await this.storeDelegationChain(chain);

    // Set up monitoring
    await this.setupDelegationMonitoring(chain);

    return chain;
  }

  /**
   * Monitor delegation usage
   */
  private async setupDelegationMonitoring(chain: DelegationChain): Promise<void> {
    // Set up activity tracking
    await this.activityMonitor.track({
      chainId: chain.id,
      monitoredUser: chain.currentHolder,
      alertOriginalOwner: true,
      alertOnUnusualActivity: true,
      maxActionsPerHour: 50
    });

    // Set up expiry monitoring
    if (chain.expiresAt) {
      await this.scheduleExpiryCheck(chain);
    }
  }
}
```

### n8n Permission Workflow

```json
{
  "name": "List Sharing Workflow",
  "nodes": [
    {
      "type": "n8n-nodes-base.webhook",
      "name": "Share Request",
      "parameters": {
        "path": "share-list",
        "responseMode": "lastNode"
      }
    },
    {
      "type": "n8n-nodes-base.function",
      "name": "Validate Permissions",
      "parameters": {
        "functionCode": `
          const { listId, sharedBy, shareWith, permissionLevel } = $input.item.json;

          // Check if user can share
          const canShare = await checkUserPermission(sharedBy, listId, 'share');

          if (!canShare) {
            throw new Error('User does not have permission to share this list');
          }

          // Validate target users exist
          const validTargets = [];
          for (const target of shareWith) {
            const user = await findUser(target);
            if (user) {
              validTargets.push(user);
            }
          }

          // Check for circular sharing
          const circular = await detectCircularSharing(listId, validTargets);
          if (circular) {
            throw new Error('Circular sharing detected');
          }

          return {
            json: {
              listId,
              sharedBy,
              validTargets,
              permissionLevel,
              validated: true
            }
          };
        `
      }
    },
    {
      "type": "n8n-nodes-base.postgres",
      "name": "Create Permissions",
      "parameters": {
        "operation": "executeQuery",
        "query": `
          INSERT INTO list_permissions (
            list_id,
            granted_to_type,
            granted_to_id,
            granted_by,
            permission_level,
            capabilities,
            created_at
          )
          SELECT
            $1 as list_id,
            'user' as granted_to_type,
            unnest($2::uuid[]) as granted_to_id,
            $3 as granted_by,
            $4 as permission_level,
            $5 as capabilities,
            NOW() as created_at
          ON CONFLICT (list_id, granted_to_type, granted_to_id)
          WHERE revoked_at IS NULL
          DO UPDATE SET
            permission_level = EXCLUDED.permission_level,
            capabilities = EXCLUDED.capabilities,
            updated_at = NOW()
          RETURNING *
        `,
        "additionalFields": {
          "queryParams": "={{$json.queryParams}}"
        }
      }
    },
    {
      "type": "n8n-nodes-base.telegram",
      "name": "Send Notifications",
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{$json.telegramChatId}}",
        "text": `
üìã *List Shared With You*

{{$json.sharedByName}} has shared "{{$json.listName}}" with you.

Permission: {{$json.permissionLevel}}
{{#if $json.message}}
Message: {{$json.message}}
{{/if}}

[Accept Share]({{$json.acceptLink}})
[View List]({{$json.viewLink}})
        `,
        "additionalFields": {
          "parse_mode": "Markdown",
          "disable_web_page_preview": true
        }
      }
    }
  ]
}
```

## Implementation Checklist

### Phase 1: Database Setup

- [ ] Create permission tables with constraints
- [ ] Implement RLS policies
- [ ] Set up audit logging
- [ ] Add sharing group tables

### Phase 2: Core Permission Logic

- [ ] Build PermissionManagementService
- [ ] Implement permission inheritance
- [ ] Add conflict resolution
- [ ] Create delegation tracking

### Phase 3: Telegram Integration

- [ ] Add sharing commands
- [ ] Build interactive sharing flow
- [ ] Implement permission management UI
- [ ] Add invitation acceptance flow

### Phase 4: Advanced Features

- [ ] Implement shareable links
- [ ] Add approval workflows
- [ ] Build analytics dashboard
- [ ] Create bulk sharing operations

## Testing Requirements

```typescript
describe('Permission System', () => {
  describe('Sharing Operations', () => {
    it('should enforce permission hierarchy', async () => {
      const owner = 'owner-id';
      const editor = 'editor-id';
      const viewer = 'viewer-id';

      // Owner shares with editor
      await permissionService.shareList(listId, owner, {
        users: [{ id: editor, level: 'editor' }]
      });

      // Editor tries to share with viewer (should succeed)
      await permissionService.shareList(listId, editor, {
        users: [{ id: viewer, level: 'viewer' }]
      });

      // Viewer tries to share (should fail)
      await expect(
        permissionService.shareList(listId, viewer, {
          users: [{ id: 'another-user', level: 'viewer' }]
        })
      ).rejects.toThrow(ForbiddenError);
    });

    it('should prevent circular sharing', async () => {
      // A shares with B
      await permissionService.shareList(listA, userA, {
        users: [{ id: userB, level: 'admin' }]
      });

      // B shares their list with A
      await permissionService.shareList(listB, userB, {
        users: [{ id: userA, level: 'admin' }]
      });

      // Attempting to create circular dependency should fail
      const circular = await permissionService.detectCircularSharing(
        [listA, listB]
      );
      expect(circular).toBe(true);
    });

    it('should respect time-based constraints', async () => {
      const permission = await permissionService.createTemporaryShare(
        listId,
        userId,
        {
          duration: '24h',
          level: 'editor'
        }
      );

      // Access should work immediately
      expect(await permissionService.hasAccess(listId, userId)).toBe(true);

      // Fast-forward 25 hours
      jest.advanceTimersByTime(25 * 60 * 60 * 1000);

      // Access should be revoked
      expect(await permissionService.hasAccess(listId, userId)).toBe(false);
    });
  });
});
```

## Performance Specifications

- Permission check: < 10ms for direct permissions
- Inheritance calculation: < 50ms for complex hierarchies
- Bulk sharing: 100+ users in < 1 second
- Share link generation: < 20ms
- Permission updates: < 100ms with notifications

## Security Requirements

- Enforce principle of least privilege
- Audit all permission changes
- Validate all sharing targets
- Implement rate limiting for shares (50/day/user)
- Encrypt shareable link tokens
- Require 2FA for owner permission changes
- Auto-revoke unused permissions after 90 days

## Developer Resources

### Essential Documentation

```bash
# PostgreSQL RLS best practices
mcp__ref__ref_search_documentation "PostgreSQL row level security sharing permissions"

# OAuth 2.0 permission models
mcp__ref__ref_search_documentation "OAuth 2.0 granular permission scopes"

# Telegram bot user management
mcp__ref__ref_search_documentation "Telegram bot multi-user permission management"
```

### Debugging Commands

```sql
-- Check user's effective permissions
WITH RECURSIVE permission_chain AS (
  SELECT * FROM list_permissions
  WHERE granted_to_id = 'user-id' AND list_id = 'list-id'
  UNION ALL
  SELECT p.* FROM list_permissions p
  JOIN sharing_group_members sgm ON p.granted_to_id = sgm.group_id::text
  WHERE sgm.user_id = 'user-id'
)
SELECT DISTINCT ON (list_id)
  list_id,
  permission_level,
  array_agg(DISTINCT granted_to_type) as sources
FROM permission_chain
GROUP BY list_id, permission_level
ORDER BY list_id,
  CASE permission_level
    WHEN 'owner' THEN 1
    WHEN 'admin' THEN 2
    WHEN 'editor' THEN 3
    WHEN 'viewer' THEN 4
  END;

-- Audit trail for list
SELECT
  action,
  actor_id,
  target_type,
  target_id,
  created_at
FROM permission_audit_log
WHERE list_id = 'list-id'
ORDER BY created_at DESC
LIMIT 20;
```

## Acceptance Criteria

1. ‚úÖ Users can share lists with granular permissions
2. ‚úÖ Permission inheritance works correctly
3. ‚úÖ Shareable links can be created with constraints
4. ‚úÖ Telegram interface provides easy sharing flow
5. ‚úÖ Audit trail tracks all permission changes
6. ‚úÖ Performance meets specifications under load

## Notes for Developers

- Cache permission checks for performance
- Use database transactions for permission updates
- Implement soft deletes for audit trail
- Consider GDPR compliance for sharing data
- Plan for permission migration tools
- Document permission precedence clearly
