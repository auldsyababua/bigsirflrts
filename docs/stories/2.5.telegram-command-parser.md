# Story 2.5: Telegram Command Parser

## Overview

Implement a robust command parsing system for the Telegram bot using grammY framework, supporting natural language input and structured commands.

## Context

- **Epic**: Epic 2 - Telegram Bot Interface
- **Priority**: P0 (Critical for MVP)
- **Dependencies**:
  - Story 2.1 (Bot initialization) - In Progress
  - Story 3.1 (OpenProject API) - COMPLETED
- **Blocks**: All user interactions via Telegram

## Technical Requirements

### Command Structure

```typescript
// Command patterns supported
interface CommandPattern {
  // Slash commands
  slash: '/command [args]';           // /task Buy milk

  // Natural language
  natural: 'action item [params]';    // "remind me to call John at 3pm"

  // Quick actions
  quick: '!action [item]';            // !task Meeting prep

  // Inline queries
  inline: '@bot_name query';          // @flrts_bot search tasks
}

// Command registry
interface Command {
  name: string;
  aliases: string[];
  pattern: RegExp;
  description: string;
  category: 'task' | 'reminder' | 'list' | 'report' | 'help';
  handler: CommandHandler;
  middleware?: Middleware[];
}
```

### grammY Bot Setup with TypeScript

```typescript
import { Bot, Context, SessionFlavor, session } from 'grammy';
import { conversations, createConversation, ConversationFlavor } from '@grammyjs/conversations';
import { I18n, I18nFlavor } from '@grammyjs/i18n';
import { parseMode } from '@grammyjs/parse-mode';
import { Fluent } from '@grammyjs/fluent';

// Enhanced context type
type MyContext = Context &
  SessionFlavor<SessionData> &
  ConversationFlavor &
  I18nFlavor &
  FluentFlavor;

interface SessionData {
  userId: string;
  currentContext?: 'task' | 'reminder' | 'list';
  lastCommand?: string;
  pendingAction?: any;
  language: 'en' | 'es' | 'de';
}

// Bot initialization
const bot = new Bot<MyContext>(process.env.TELEGRAM_BOT_TOKEN!);

// Middleware setup
bot.use(session({
  initial: (): SessionData => ({
    userId: '',
    language: 'en'
  })
}));

bot.use(conversations());
bot.use(parseMode('Markdown'));

// i18n for multi-language support
const i18n = new I18n<MyContext>({
  defaultLocale: 'en',
  directory: 'locales',
});
bot.use(i18n);
```

### Command Parser Implementation

#### 1. Core Parser Class

```typescript
import { Context } from 'grammy';
import chrono from 'chrono-node'; // For date/time parsing

class CommandParser {
  private commands: Map<string, Command> = new Map();
  private patterns: Array<{ pattern: RegExp; handler: string }> = [];

  registerCommand(command: Command) {
    this.commands.set(command.name, command);
    command.aliases.forEach(alias => {
      this.commands.set(alias, command);
    });
    this.patterns.push({
      pattern: command.pattern,
      handler: command.name
    });
  }

  async parse(text: string, ctx: Context): Promise<ParsedCommand | null> {
    // Remove bot mention if present
    const cleanText = text.replace(/@\w+bot\s?/gi, '').trim();

    // Try exact command match first
    const directCommand = this.parseDirectCommand(cleanText);
    if (directCommand) return directCommand;

    // Try pattern matching
    const patternMatch = this.parsePattern(cleanText);
    if (patternMatch) return patternMatch;

    // Try natural language processing
    const nlpResult = await this.parseNaturalLanguage(cleanText, ctx);
    if (nlpResult) return nlpResult;

    return null;
  }

  private parseDirectCommand(text: string): ParsedCommand | null {
    const match = text.match(/^[\/!](\w+)\s*(.*)$/);
    if (!match) return null;

    const [, commandName, args] = match;
    const command = this.commands.get(commandName.toLowerCase());

    if (!command) return null;

    return {
      command: command.name,
      args: this.parseArguments(args),
      raw: text,
      type: 'direct'
    };
  }

  private parsePattern(text: string): ParsedCommand | null {
    for (const { pattern, handler } of this.patterns) {
      const match = text.match(pattern);
      if (match) {
        return {
          command: handler,
          args: match.groups || {},
          raw: text,
          type: 'pattern'
        };
      }
    }
    return null;
  }

  private async parseNaturalLanguage(
    text: string,
    ctx: Context
  ): Promise<ParsedCommand | null> {
    // Extract intent and entities
    const intent = this.detectIntent(text);
    const entities = this.extractEntities(text);

    if (!intent) return null;

    return {
      command: intent,
      args: entities,
      raw: text,
      type: 'natural'
    };
  }

  private detectIntent(text: string): string | null {
    const intents = {
      task: /\b(task|todo|do|complete|finish)\b/i,
      reminder: /\b(remind|reminder|alert|notify)\b/i,
      list: /\b(list|show|display|view)\b/i,
      report: /\b(report|summary|stats|status)\b/i,
    };

    for (const [intent, pattern] of Object.entries(intents)) {
      if (pattern.test(text)) return intent;
    }
    return null;
  }

  private extractEntities(text: string): Record<string, any> {
    const entities: Record<string, any> = {};

    // Extract datetime using chrono
    const dateResult = chrono.parse(text);
    if (dateResult.length > 0) {
      entities.datetime = dateResult[0].start.date();
      entities.dateText = dateResult[0].text;
    }

    // Extract quoted strings as titles/descriptions
    const quotedMatch = text.match(/"([^"]+)"/);
    if (quotedMatch) {
      entities.title = quotedMatch[1];
    }

    // Extract mentions
    const mentions = text.match(/@(\w+)/g);
    if (mentions) {
      entities.mentions = mentions.map(m => m.substring(1));
    }

    // Extract priority markers
    if (/\b(urgent|high|asap)\b/i.test(text)) {
      entities.priority = 'high';
    } else if (/\b(low|later|sometime)\b/i.test(text)) {
      entities.priority = 'low';
    }

    return entities;
  }

  private parseArguments(argsString: string): Record<string, any> {
    const args: Record<string, any> = {};

    // Parse key=value pairs
    const kvPairs = argsString.match(/(\w+)=("[^"]+"|'[^']+'|\S+)/g);
    if (kvPairs) {
      kvPairs.forEach(pair => {
        const [key, value] = pair.split('=');
        args[key] = value.replace(/^["']|["']$/g, '');
      });
    }

    // Parse remaining as positional arguments
    const remaining = argsString
      .replace(/(\w+)=("[^"]+"|'[^']+'|\S+)/g, '')
      .trim();
    if (remaining) {
      args.text = remaining;
    }

    return args;
  }
}

interface ParsedCommand {
  command: string;
  args: Record<string, any>;
  raw: string;
  type: 'direct' | 'pattern' | 'natural';
}
```

#### 2. Command Definitions

```typescript
// Task command
const taskCommand: Command = {
  name: 'task',
  aliases: ['t', 'todo'],
  pattern: /^(?:create\s+)?task\s+(?<title>.+?)(?:\s+due\s+(?<due>.+?))?$/i,
  description: 'Create a new task',
  category: 'task',
  handler: async (ctx, parsed) => {
    const { title, due } = parsed.args;

    // Validate input
    if (!title) {
      return ctx.reply('‚ùå Please provide a task title');
    }

    // Parse due date if provided
    let dueDate = null;
    if (due) {
      dueDate = chrono.parseDate(due);
      if (!dueDate) {
        return ctx.reply('‚ùå Could not understand the due date');
      }
    }

    // Queue job for processing
    const queue = QueueFactory.getQueue(QueueNames.TASK_CREATE);
    await queue.add('create-task', {
      userId: ctx.from!.id.toString(),
      title,
      dueDate,
      source: 'telegram'
    });

    // Send confirmation with inline keyboard
    await ctx.reply(
      `‚úÖ Task queued: "${title}"${dueDate ? `\nüìÖ Due: ${dueDate.toLocaleDateString()}` : ''}`,
      {
        reply_markup: {
          inline_keyboard: [[
            { text: 'üìù Add details', callback_data: `task:details:${title}` },
            { text: 'üë• Assign', callback_data: `task:assign:${title}` }
          ]]
        }
      }
    );
  }
};

// Reminder command
const reminderCommand: Command = {
  name: 'reminder',
  aliases: ['r', 'remind', 'remindme'],
  pattern: /^remind(?:\s+me)?\s+(?:to\s+)?(?<action>.+?)\s+(?:at|on|in)\s+(?<when>.+)$/i,
  description: 'Set a reminder',
  category: 'reminder',
  handler: async (ctx, parsed) => {
    const { action, when } = parsed.args;

    const reminderTime = chrono.parseDate(when);
    if (!reminderTime) {
      // Start conversation for clarification
      await ctx.conversation.enter('clarifyTime');
      return;
    }

    // Store reminder
    await storeReminder({
      userId: ctx.from!.id,
      action,
      time: reminderTime,
      chatId: ctx.chat!.id
    });

    await ctx.reply(
      `‚è∞ Reminder set for ${reminderTime.toLocaleString()}\n"${action}"`
    );
  }
};

// List command with pagination
const listCommand: Command = {
  name: 'list',
  aliases: ['ls', 'show'],
  pattern: /^list\s+(?<type>tasks?|reminders?|all)(?:\s+(?<filter>.+))?$/i,
  description: 'List items',
  category: 'list',
  handler: async (ctx, parsed) => {
    const { type, filter } = parsed.args;
    const page = 1;
    const limit = 5;

    const items = await fetchItems(ctx.from!.id, type, filter, page, limit);

    if (items.length === 0) {
      return ctx.reply('üì≠ No items found');
    }

    const message = formatItemList(items);
    const keyboard = createPaginationKeyboard(page, items.totalPages);

    await ctx.reply(message, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }
};
```

### Conversation Handlers (Multi-step interactions)

```typescript
import { createConversation } from '@grammyjs/conversations';

// Multi-step task creation
async function createTaskConversation(
  conversation: Conversation<MyContext>,
  ctx: MyContext
) {
  await ctx.reply('üìù Let\'s create a task. What\'s the title?');
  const { message: titleMsg } = await conversation.wait();

  if (!titleMsg?.text) {
    return ctx.reply('‚ùå Cancelled');
  }

  const title = titleMsg.text;

  await ctx.reply('üìÖ When is it due? (or type "skip")');
  const { message: dueMsg } = await conversation.wait();

  let dueDate = null;
  if (dueMsg?.text && dueMsg.text.toLowerCase() !== 'skip') {
    dueDate = chrono.parseDate(dueMsg.text);
    if (!dueDate) {
      await ctx.reply('‚ö†Ô∏è Could not parse date, skipping...');
    }
  }

  await ctx.reply('üìã Any additional details? (or type "skip")');
  const { message: detailsMsg } = await conversation.wait();

  const details = detailsMsg?.text === 'skip' ? null : detailsMsg?.text;

  // Create the task
  const task = await createTask({
    title,
    dueDate,
    description: details,
    userId: ctx.from!.id
  });

  await ctx.reply(`‚úÖ Task created!\nID: ${task.id}\nTitle: ${task.title}`);
}

bot.use(createConversation(createTaskConversation));
```

### Inline Query Handler

```typescript
bot.on('inline_query', async (ctx) => {
  const query = ctx.inlineQuery.query;

  if (!query) {
    // Show recent items
    const recentItems = await getRecentItems(ctx.from.id);
    return ctx.answerInlineQuery(
      recentItems.map(item => ({
        type: 'article',
        id: item.id,
        title: item.title,
        description: item.description,
        input_message_content: {
          message_text: formatItem(item),
          parse_mode: 'Markdown'
        }
      }))
    );
  }

  // Search items
  const results = await searchItems(ctx.from.id, query);
  await ctx.answerInlineQuery(results, {
    cache_time: 30,
    is_personal: true
  });
});
```

### Error Handling & Validation

```typescript
// Command validation middleware
async function validateCommand(ctx: Context, next: NextFunction) {
  const text = ctx.message?.text || ctx.callbackQuery?.data;

  if (!text) {
    return next();
  }

  // Check for SQL injection attempts
  if (/(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION)\b)/i.test(text)) {
    await ctx.reply('‚ö†Ô∏è Invalid input detected');
    return;
  }

  // Validate command length
  if (text.length > 1000) {
    await ctx.reply('‚ùå Command too long (max 1000 characters)');
    return;
  }

  return next();
}

bot.use(validateCommand);

// Global error handler
bot.catch((err) => {
  const ctx = err.ctx;
  console.error(`Error while handling update ${ctx.update.update_id}:`);
  console.error(err.error);

  ctx.reply('‚ùå An error occurred. Please try again later.').catch(() => {
    // Ignore errors when sending error message
  });
});
```

### Command Help System

```typescript
class HelpSystem {
  static generateHelp(category?: string): string {
    const commands = commandRegistry.getCommands(category);

    let help = 'üìö *Available Commands*\n\n';

    const grouped = this.groupByCategory(commands);

    for (const [cat, cmds] of Object.entries(grouped)) {
      help += `*${cat.toUpperCase()}*\n`;
      for (const cmd of cmds) {
        help += `‚Ä¢ /${cmd.name} - ${cmd.description}\n`;
        if (cmd.aliases.length > 0) {
          help += `  _Aliases: ${cmd.aliases.join(', ')}_\n`;
        }
      }
      help += '\n';
    }

    help += '\nüí° *Natural Language Examples:*\n';
    help += '‚Ä¢ "Remind me to call John tomorrow at 3pm"\n';
    help += '‚Ä¢ "Create task Review PR #123"\n';
    help += '‚Ä¢ "Show my tasks for this week"\n';

    return help;
  }

  private static groupByCategory(commands: Command[]): Record<string, Command[]> {
    return commands.reduce((acc, cmd) => {
      if (!acc[cmd.category]) acc[cmd.category] = [];
      acc[cmd.category].push(cmd);
      return acc;
    }, {} as Record<string, Command[]>);
  }
}

bot.command('help', async (ctx) => {
  const category = ctx.match;
  const help = HelpSystem.generateHelp(category);
  await ctx.reply(help, { parse_mode: 'Markdown' });
});
```

## Implementation Checklist

### Phase 1: Core Setup

- [ ] Set up grammY bot with TypeScript
- [ ] Configure session management
- [ ] Implement basic command parser
- [ ] Add command registration system

### Phase 2: Command Implementation

- [ ] Implement task commands
- [ ] Implement reminder commands
- [ ] Add list/search commands
- [ ] Create help system

### Phase 3: Natural Language

- [ ] Integrate chrono for date parsing
- [ ] Add intent detection
- [ ] Implement entity extraction
- [ ] Create conversation flows

### Phase 4: Advanced Features

- [ ] Add inline queries
- [ ] Implement command shortcuts
- [ ] Add multi-language support
- [ ] Create command autocomplete

## Testing Requirements

```typescript
import { Bot } from 'grammy';
import { expect } from 'chai';

describe('Command Parser', () => {
  let parser: CommandParser;

  beforeEach(() => {
    parser = new CommandParser();
    parser.registerCommand(taskCommand);
  });

  it('should parse direct commands', () => {
    const result = parser.parse('/task Buy milk');
    expect(result?.command).to.equal('task');
    expect(result?.args.text).to.equal('Buy milk');
  });

  it('should parse natural language', async () => {
    const result = await parser.parse('remind me to call John at 3pm tomorrow');
    expect(result?.command).to.equal('reminder');
    expect(result?.args.action).to.equal('call John');
    expect(result?.args.datetime).to.be.instanceOf(Date);
  });

  it('should handle command aliases', () => {
    const result = parser.parse('/t Quick task');
    expect(result?.command).to.equal('task');
  });
});
```

## Performance Specifications

- Command parsing: < 50ms
- Response time: < 200ms for simple commands
- Conversation timeout: 5 minutes
- Inline query cache: 30 seconds
- Max command length: 1000 characters

## Security Requirements

- Sanitize all user input
- Validate command permissions per user
- Rate limit: 30 commands/minute per user
- Escape markdown in user-generated content
- Log all commands for audit trail

## Developer Resources

### Essential Documentation

```bash
# grammY framework docs
mcp__ref__ref_search_documentation "grammY TypeScript bot commands middleware"

# Natural language date parsing
mcp__ref__ref_search_documentation "chrono-node TypeScript date parsing"

# Telegram Bot API
mcp__ref__ref_search_documentation "Telegram Bot API inline queries commands"
```

## Acceptance Criteria

1. ‚úÖ All command types are parsed correctly
2. ‚úÖ Natural language input works for common phrases
3. ‚úÖ Multi-step conversations maintain context
4. ‚úÖ Error messages are user-friendly
5. ‚úÖ Help system shows all available commands
6. ‚úÖ Commands are processed within 200ms

## Notes for Developers

- Use grammY's built-in middleware for common tasks
- Implement command parsing as pure functions for testability
- Store conversation state in Redis for scalability
- Use TypeScript strict mode for type safety
- Test with various date formats and timezones
- Consider implementing command suggestions based on usage patterns
