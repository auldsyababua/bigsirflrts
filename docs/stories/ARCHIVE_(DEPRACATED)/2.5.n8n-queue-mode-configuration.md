# Story 2.5: n8n Queue Mode Configuration for Production Scale

**Priority:** CRITICAL
**Points:** 8
**Status:** Ready for Development

## User Story

As a **system administrator**, I want **n8n running in queue mode with Redis** so that **the system can handle high-volume webhook traffic and scale horizontally as needed**.

## Business Value

- Enables horizontal scaling by adding worker nodes
- Prevents webhook timeout failures during high load
- Provides fault tolerance through distributed processing
- Supports the "Brain" component of our Reflex-Brain architecture
- Reduces single point of failure risks

## Context: Why Queue Mode is Essential

Our architecture receives webhooks from multiple sources:

- Telegram messages (via Edge Functions)
- OpenProject work package updates
- Supabase database changes
- Future: Email, Slack, SMS integrations

Without queue mode, a single n8n instance becomes a bottleneck, causing:

- Webhook timeouts during complex processing
- Lost messages during high traffic
- No ability to scale for growth
- Single point of failure

## Acceptance Criteria

### Primary Acceptance Criteria

- [ ] n8n main instance running with queue mode enabled
- [ ] At least 2 worker instances processing jobs
- [ ] Redis configured as message broker
- [ ] Webhook processor handling incoming requests
- [ ] Health monitoring endpoints accessible

### Technical Acceptance Criteria

- [ ] PostgreSQL 15.8 as execution database (not SQLite)
- [ ] Redis 7+ with persistence enabled
- [ ] Shared encryption key across all instances
- [ ] Load balancer routing webhooks correctly
- [ ] Graceful shutdown configured (30s minimum)

### Performance Acceptance Criteria

- [ ] Handle 100+ concurrent webhook requests
- [ ] Worker concurrency set to 10 per instance
- [ ] Queue processing latency < 5 seconds
- [ ] Zero message loss during worker restart

## Implementation Guide

### 1. Infrastructure Setup

#### Docker Compose Configuration

```yaml
# docker-compose.yml
version: '3.8'

services:
  # PostgreSQL Database (Shared by all n8n instances)
  postgres:
    image: postgres:15.8-alpine
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: n8n
      POSTGRES_HOST_AUTH_METHOD: trust
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis Message Broker
  redis:
    image: redis:7-alpine
    restart: unless-stopped
    command: >
      redis-server
      --appendonly yes
      --appendfsync everysec
      --requirepass ${REDIS_PASSWORD}
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "--pass", "${REDIS_PASSWORD}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # n8n Main Instance (handles triggers, UI, orchestration)
  n8n-main:
    image: docker.n8n.io/n8nio/n8n:1.20.0
    restart: unless-stopped
    ports:
      - "5678:5678"
    environment:
      # Database Configuration
      DB_TYPE: postgresdb
      DB_POSTGRESDB_HOST: postgres
      DB_POSTGRESDB_PORT: 5432
      DB_POSTGRESDB_DATABASE: n8n
      DB_POSTGRESDB_USER: ${POSTGRES_USER}
      DB_POSTGRESDB_PASSWORD: ${POSTGRES_PASSWORD}

      # Queue Mode Configuration
      EXECUTIONS_MODE: queue
      QUEUE_BULL_REDIS_HOST: redis
      QUEUE_BULL_REDIS_PORT: 6379
      QUEUE_BULL_REDIS_PASSWORD: ${REDIS_PASSWORD}
      QUEUE_BULL_REDIS_DB: 0
      QUEUE_BULL_REDIS_TIMEOUT_THRESHOLD: 10000
      N8N_GRACEFUL_SHUTDOWN_TIMEOUT: 30

      # Security
      N8N_ENCRYPTION_KEY: ${N8N_ENCRYPTION_KEY}
      N8N_HOST: ${N8N_HOST}
      N8N_PORT: 5678
      N8N_PROTOCOL: https
      WEBHOOK_URL: ${WEBHOOK_URL}

      # Performance
      N8N_METRICS: true
      QUEUE_HEALTH_CHECK_ACTIVE: true

      # Optional: Multi-main setup for HA (Enterprise only)
      # N8N_MULTI_MAIN_SETUP_ENABLED: true
      # N8N_MULTI_MAIN_SETUP_KEY_TTL: 10
      # N8N_MULTI_MAIN_SETUP_CHECK_INTERVAL: 3

    volumes:
      - n8n_data:/home/node/.n8n
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:5678/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3

  # n8n Worker 1
  n8n-worker-1:
    image: docker.n8n.io/n8nio/n8n:1.20.0
    restart: unless-stopped
    command: worker --concurrency=10
    environment:
      # Same database config as main
      DB_TYPE: postgresdb
      DB_POSTGRESDB_HOST: postgres
      DB_POSTGRESDB_PORT: 5432
      DB_POSTGRESDB_DATABASE: n8n
      DB_POSTGRESDB_USER: ${POSTGRES_USER}
      DB_POSTGRESDB_PASSWORD: ${POSTGRES_PASSWORD}

      # Queue configuration
      EXECUTIONS_MODE: queue
      QUEUE_BULL_REDIS_HOST: redis
      QUEUE_BULL_REDIS_PORT: 6379
      QUEUE_BULL_REDIS_PASSWORD: ${REDIS_PASSWORD}
      QUEUE_BULL_REDIS_DB: 0
      N8N_GRACEFUL_SHUTDOWN_TIMEOUT: 30

      # MUST share encryption key with main
      N8N_ENCRYPTION_KEY: ${N8N_ENCRYPTION_KEY}

      # Worker health endpoint
      QUEUE_HEALTH_CHECK_ACTIVE: true
      N8N_PORT: 5679

    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      n8n-main:
        condition: service_healthy
    ports:
      - "5679:5679"
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:5679/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3

  # n8n Worker 2 (duplicate of worker-1 with different port)
  n8n-worker-2:
    image: docker.n8n.io/n8nio/n8n:1.20.0
    restart: unless-stopped
    command: worker --concurrency=10
    environment:
      DB_TYPE: postgresdb
      DB_POSTGRESDB_HOST: postgres
      DB_POSTGRESDB_PORT: 5432
      DB_POSTGRESDB_DATABASE: n8n
      DB_POSTGRESDB_USER: ${POSTGRES_USER}
      DB_POSTGRESDB_PASSWORD: ${POSTGRES_PASSWORD}
      EXECUTIONS_MODE: queue
      QUEUE_BULL_REDIS_HOST: redis
      QUEUE_BULL_REDIS_PORT: 6379
      QUEUE_BULL_REDIS_PASSWORD: ${REDIS_PASSWORD}
      QUEUE_BULL_REDIS_DB: 0
      N8N_GRACEFUL_SHUTDOWN_TIMEOUT: 30
      N8N_ENCRYPTION_KEY: ${N8N_ENCRYPTION_KEY}
      QUEUE_HEALTH_CHECK_ACTIVE: true
      N8N_PORT: 5680
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      n8n-main:
        condition: service_healthy
    ports:
      - "5680:5680"
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:5680/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3

  # n8n Webhook Processor (handles incoming webhooks)
  n8n-webhook:
    image: docker.n8n.io/n8nio/n8n:1.20.0
    restart: unless-stopped
    command: webhook
    ports:
      - "5681:5678"
    environment:
      DB_TYPE: postgresdb
      DB_POSTGRESDB_HOST: postgres
      DB_POSTGRESDB_PORT: 5432
      DB_POSTGRESDB_DATABASE: n8n
      DB_POSTGRESDB_USER: ${POSTGRES_USER}
      DB_POSTGRESDB_PASSWORD: ${POSTGRES_PASSWORD}
      EXECUTIONS_MODE: queue
      QUEUE_BULL_REDIS_HOST: redis
      QUEUE_BULL_REDIS_PORT: 6379
      QUEUE_BULL_REDIS_PASSWORD: ${REDIS_PASSWORD}
      QUEUE_BULL_REDIS_DB: 0
      N8N_ENCRYPTION_KEY: ${N8N_ENCRYPTION_KEY}
      WEBHOOK_URL: ${WEBHOOK_URL}
      # Disable webhook processing on main (optional)
      N8N_DISABLE_PRODUCTION_MAIN_PROCESS: false
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      n8n-main:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:5678/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Nginx Load Balancer
  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - n8n-main
      - n8n-webhook
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  postgres_data:
  redis_data:
  n8n_data:
```

### 2. Environment Configuration

#### .env File

```bash
# Database
POSTGRES_USER=n8n
POSTGRES_PASSWORD=your-secure-postgres-password
POSTGRES_HOST=postgres

# Redis
REDIS_PASSWORD=your-secure-redis-password

# n8n Configuration
N8N_ENCRYPTION_KEY=your-generated-encryption-key
N8N_HOST=n8n.10nz.tools
WEBHOOK_URL=https://n8n.10nz.tools

# Generate encryption key with:
# openssl rand -hex 32
```

### 3. Nginx Load Balancer Configuration

```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream n8n_main {
        # Main instance for UI and API
        server n8n-main:5678;
    }

    upstream n8n_webhooks {
        # Webhook processors with round-robin
        least_conn;  # Use least connections algorithm
        server n8n-webhook:5678 weight=1;
        # Add more webhook processors as needed
    }

    # Health check endpoint
    server {
        listen 80;
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }

    # Main n8n server
    server {
        listen 443 ssl http2;
        server_name n8n.10nz.tools;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        # Webhook routes go to webhook processors
        location ~ ^/webhook/ {
            proxy_pass http://n8n_webhooks;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Increase timeouts for long-running webhooks
            proxy_connect_timeout 90;
            proxy_send_timeout 90;
            proxy_read_timeout 90;
        }

        # Everything else goes to main instance
        location / {
            proxy_pass http://n8n_main;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket support for UI
            proxy_set_header Connection "upgrade";
            proxy_buffering off;
        }
    }
}
```

### 4. Monitoring and Health Checks

#### Health Check Script

```bash
#!/bin/bash
# health-check.sh

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "n8n Queue Mode Health Check"
echo "============================"

# Check PostgreSQL
echo -n "PostgreSQL: "
if docker exec bigsirflrts-postgres-1 pg_isready -U n8n &>/dev/null; then
    echo -e "${GREEN}✓ Healthy${NC}"
else
    echo -e "${RED}✗ Down${NC}"
fi

# Check Redis
echo -n "Redis: "
if docker exec bigsirflrts-redis-1 redis-cli --pass ${REDIS_PASSWORD} ping &>/dev/null; then
    echo -e "${GREEN}✓ Healthy${NC}"

    # Check queue length
    QUEUE_LENGTH=$(docker exec bigsirflrts-redis-1 redis-cli --pass ${REDIS_PASSWORD} llen bull:queue:default 2>/dev/null)
    echo "  Queue Length: ${QUEUE_LENGTH:-0} jobs"
else
    echo -e "${RED}✗ Down${NC}"
fi

# Check n8n Main
echo -n "n8n Main: "
if curl -s http://localhost:5678/healthz &>/dev/null; then
    echo -e "${GREEN}✓ Healthy${NC}"
else
    echo -e "${RED}✗ Down${NC}"
fi

# Check Workers
for PORT in 5679 5680; do
    echo -n "Worker (port $PORT): "
    if curl -s http://localhost:$PORT/healthz &>/dev/null; then
        echo -e "${GREEN}✓ Healthy${NC}"
    else
        echo -e "${YELLOW}⚠ Not responding${NC}"
    fi
done

# Check Webhook Processor
echo -n "Webhook Processor: "
if curl -s http://localhost:5681/healthz &>/dev/null; then
    echo -e "${GREEN}✓ Healthy${NC}"
else
    echo -e "${YELLOW}⚠ Not responding${NC}"
fi

# Check metrics endpoint
echo -n "Metrics: "
if curl -s http://localhost:5678/metrics &>/dev/null; then
    echo -e "${GREEN}✓ Available${NC}"
else
    echo -e "${YELLOW}⚠ Not available${NC}"
fi
```

### 5. Performance Tuning

#### Redis Configuration for Production

```redis
# redis.conf
# Persistence
appendonly yes
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# Memory Management
maxmemory 512mb
maxmemory-policy allkeys-lru

# Performance
tcp-keepalive 60
timeout 300
tcp-backlog 511

# Queue-specific settings
# Increase these for high-volume environments
list-max-ziplist-size -2
list-compress-depth 0
```

#### PostgreSQL Tuning

```sql
-- Performance settings for n8n
ALTER SYSTEM SET max_connections = 200;
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET wal_buffers = '16MB';
ALTER SYSTEM SET default_statistics_target = 100;
ALTER SYSTEM SET random_page_cost = 1.1;
ALTER SYSTEM SET effective_io_concurrency = 200;
ALTER SYSTEM SET work_mem = '4MB';

-- Apply changes
SELECT pg_reload_conf();

-- Create indexes for n8n performance
CREATE INDEX idx_execution_workflow ON execution_entity(workflowId);
CREATE INDEX idx_execution_status ON execution_entity(status);
CREATE INDEX idx_execution_started ON execution_entity(startedAt);
```

### 6. Deployment Script

```bash
#!/bin/bash
# deploy-queue-mode.sh

set -e

echo "Deploying n8n in Queue Mode"
echo "==========================="

# Check prerequisites
command -v docker >/dev/null 2>&1 || { echo "Docker required but not installed. Aborting." >&2; exit 1; }
command -v docker-compose >/dev/null 2>&1 || { echo "Docker Compose required but not installed. Aborting." >&2; exit 1; }

# Generate encryption key if not exists
if [ -z "$N8N_ENCRYPTION_KEY" ]; then
    echo "Generating encryption key..."
    export N8N_ENCRYPTION_KEY=$(openssl rand -hex 32)
    echo "N8N_ENCRYPTION_KEY=$N8N_ENCRYPTION_KEY" >> .env
    echo "⚠️  IMPORTANT: Save this encryption key securely!"
fi

# Start services in order
echo "Starting PostgreSQL..."
docker-compose up -d postgres
sleep 10

echo "Starting Redis..."
docker-compose up -d redis
sleep 5

echo "Starting n8n main instance..."
docker-compose up -d n8n-main
sleep 10

echo "Starting workers..."
docker-compose up -d n8n-worker-1 n8n-worker-2
sleep 5

echo "Starting webhook processor..."
docker-compose up -d n8n-webhook
sleep 5

echo "Starting load balancer..."
docker-compose up -d nginx

echo ""
echo "Deployment complete! Running health check..."
sleep 5
./health-check.sh

echo ""
echo "Access n8n at: https://n8n.10nz.tools"
echo "Monitor workers at: Settings > Workers (Enterprise only)"
```

## Testing Requirements

### Load Testing

```bash
# Test webhook handling capacity
# install: npm install -g artillery

# artillery-test.yml
config:
  target: "https://n8n.10nz.tools"
  phases:
    - duration: 60
      arrivalRate: 10
      rampTo: 100
scenarios:
  - name: "Webhook Load Test"
    flow:
      - post:
          url: "/webhook/telegram-test"
          json:
            message: "Test message {{ $randomNumber() }}"
            timestamp: "{{ $timestamp() }}"

# Run test
artillery run artillery-test.yml
```

### Integration Testing

- [ ] Test webhook delivery during worker restart
- [ ] Test queue overflow handling (Redis memory limit)
- [ ] Test graceful shutdown (30-second timeout)
- [ ] Test worker health endpoint responses
- [ ] Test load balancer routing rules

## Monitoring Dashboard Queries

```sql
-- Queue performance metrics
SELECT
  DATE_TRUNC('minute', started_at) as minute,
  COUNT(*) as executions,
  AVG(EXTRACT(EPOCH FROM (finished_at - started_at))) as avg_duration_seconds,
  COUNT(CASE WHEN status = 'error' THEN 1 END) as errors
FROM execution_entity
WHERE started_at > NOW() - INTERVAL '1 hour'
GROUP BY DATE_TRUNC('minute', started_at)
ORDER BY minute DESC;

-- Worker utilization
SELECT
  worker_id,
  COUNT(*) as jobs_processed,
  AVG(duration_ms) as avg_processing_time,
  MAX(last_seen) as last_activity
FROM worker_stats
WHERE last_seen > NOW() - INTERVAL '5 minutes'
GROUP BY worker_id;
```

## Troubleshooting Guide

### Common Issues and Solutions

1. **Workers not picking up jobs**
   - Check Redis connectivity: `redis-cli --pass $REDIS_PASSWORD ping`
   - Verify encryption key matches across all instances
   - Check worker logs: `docker logs n8n-worker-1`

2. **High memory usage**
   - Tune worker concurrency (reduce from 10 to 5)
   - Increase Redis memory limit
   - Enable execution pruning in n8n settings

3. **Webhook timeouts**
   - Add more webhook processors
   - Check nginx timeout settings
   - Monitor Redis queue length

4. **Database connection pool exhausted**
   - Reduce worker concurrency
   - Increase PostgreSQL max_connections
   - Use fewer workers with higher concurrency

## Dependencies

- Docker and Docker Compose
- PostgreSQL 15.8
- Redis 7+
- Nginx for load balancing
- SSL certificates for HTTPS
- Domain configured (n8n.10nz.tools)

## Definition of Done

- [ ] All services running in queue mode
- [ ] Health checks passing for all components
- [ ] Load test showing 100+ concurrent webhook capacity
- [ ] Monitoring dashboard configured
- [ ] Runbook documented for operations team
- [ ] Backup and recovery procedures tested

## References

- [n8n Queue Mode Documentation](https://docs.n8n.io/hosting/scaling/queue-mode/)
- [Redis Queue Patterns](https://redis.io/docs/manual/patterns/reliability/)
- [PostgreSQL Performance Tuning](https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server)
- [Docker Compose Best Practices](https://docs.docker.com/compose/production/)
- [Nginx Load Balancing](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/)

---

*Story follows BMAD framework v5 standards*
*Created for Sprint 2 - Integration Layer*
