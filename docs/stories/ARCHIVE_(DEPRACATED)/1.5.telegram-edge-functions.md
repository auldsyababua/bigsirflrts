# Story 1.5: Edge Functions for Immediate Telegram Responses

**Priority:** CRITICAL
**Points:** 8
**Status:** Ready for Development

## User Story

As a **field technician using Telegram**, I want **instant acknowledgment when I send messages** so that **I know my message was received even before complex processing completes**.

## Business Value

- Provides sub-500ms response times for Telegram webhook requirements
- Prevents timeout errors and webhook failures
- Improves user experience with immediate feedback
- Enables "Reflex and Brain" architecture pattern
- Reduces perceived latency for field operations

## Context: The 500ms Rule

Telegram requires webhook responses within a reasonable timeframe. While not strictly enforced at 500ms, best practices recommend responding quickly to prevent:

- Webhook retries (causing duplicate processing)
- Connection timeouts in poor network conditions
- User perception of unresponsive bot

Our n8n workflows have 20-50ms baseline latency plus processing time, often exceeding 500ms for complex operations. Edge Functions provide the "reflex" layer for immediate responses.

## Acceptance Criteria

### Primary Acceptance Criteria

- [ ] Edge Function deployed to Supabase handling Telegram webhooks
- [ ] Response time < 200ms for acknowledgment messages
- [ ] Message queued to n8n for complex processing
- [ ] Fallback handling when n8n is unavailable
- [ ] Webhook signature validation implemented

### Technical Acceptance Criteria

- [ ] Supabase Edge Function created with Deno runtime
- [ ] Redis queue integration for n8n handoff
- [ ] Telegram Bot API webhook properly configured
- [ ] Error handling for malformed requests
- [ ] Monitoring and logging implemented

### Performance Acceptance Criteria

- [ ] P95 response time < 200ms
- [ ] P99 response time < 500ms
- [ ] Zero message loss during handoff
- [ ] Graceful degradation when queue is full

## Implementation Guide

### 1. Supabase Edge Function Setup

#### Create Function with Supabase CLI

```bash
# Initialize Supabase in your project
supabase init

# Create the Edge Function
supabase functions new telegram-webhook

# Deploy with JWT verification disabled (Telegram uses its own auth)
supabase functions deploy telegram-webhook --no-verify-jwt
```

#### Core Edge Function Implementation

```typescript
// supabase/functions/telegram-webhook/index.ts
import { serve } from "https://deno.land/std@0.208.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.0";
import { Bot, webhookCallback } from "https://deno.land/x/grammy@v1.19.2/mod.ts";
import { Redis } from "https://deno.land/x/redis@v0.31.0/mod.ts";

// Environment variables
const BOT_TOKEN = Deno.env.get("TELEGRAM_BOT_TOKEN")!;
const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const REDIS_URL = Deno.env.get("REDIS_URL")!;
const WEBHOOK_SECRET = Deno.env.get("TELEGRAM_WEBHOOK_SECRET")!;

// Initialize clients
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);
const redis = await Redis.connect({ url: REDIS_URL });

// Performance timer utility
class PerformanceTimer {
  private startTime: number;

  constructor() {
    this.startTime = Date.now();
  }

  elapsed(): number {
    return Date.now() - this.startTime;
  }

  checkpoint(label: string): void {
    console.log(`[PERF] ${label}: ${this.elapsed()}ms`);
  }
}

serve(async (req: Request) => {
  const timer = new PerformanceTimer();

  try {
    // 1. Validate webhook signature (Telegram's secret token)
    const secretToken = req.headers.get("X-Telegram-Bot-Api-Secret-Token");
    if (secretToken !== WEBHOOK_SECRET) {
      return new Response("Unauthorized", { status: 401 });
    }
    timer.checkpoint("Auth validated");

    // 2. Parse incoming update
    const update = await req.json();
    const chatId = update.message?.chat?.id;
    const messageText = update.message?.text;
    const userId = update.message?.from?.id;
    const messageId = update.message?.message_id;

    timer.checkpoint("Payload parsed");

    // 3. Quick validation
    if (!chatId || !messageText) {
      return new Response("OK", { status: 200 });
    }

    // 4. Send immediate acknowledgment via Telegram API
    const acknowledgment = await sendQuickReply(chatId, messageId, messageText);
    timer.checkpoint("Acknowledgment sent");

    // 5. Queue for n8n processing (non-blocking)
    const queuePromise = queueForProcessing(update, timer);

    // 6. Log to Supabase (non-blocking)
    const logPromise = logToSupabase(update, timer.elapsed());

    // Don't wait for queue or log - respond immediately
    console.log(`[COMPLETE] Total time: ${timer.elapsed()}ms`);

    return new Response(JSON.stringify({
      ok: true,
      acknowledged: true,
      processingTime: timer.elapsed()
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });

  } catch (error) {
    console.error("Edge function error:", error);

    // Even on error, return 200 to prevent Telegram retries
    return new Response(JSON.stringify({
      ok: true,
      error: true,
      message: "Queued for retry"
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  }
});

// Quick reply function - returns immediately
async function sendQuickReply(
  chatId: number,
  replyToId: number,
  originalText: string
): Promise<void> {
  const quickResponses: Record<string, string> = {
    "/start": "ðŸ‘‹ Welcome! Setting up your workspace...",
    "/help": "ðŸ“š Loading help menu...",
    "/status": "ðŸ”„ Checking system status...",
    "default": "âœ… Message received! Processing..."
  };

  // Determine response based on command
  const command = originalText.split(" ")[0].toLowerCase();
  const responseText = quickResponses[command] || quickResponses.default;

  // Fire and forget - don't await
  fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      chat_id: chatId,
      text: responseText,
      reply_to_message_id: replyToId,
      parse_mode: "HTML"
    })
  }).catch(err => console.error("Failed to send acknowledgment:", err));
}

// Queue for n8n processing
async function queueForProcessing(update: any, timer: PerformanceTimer): Promise<void> {
  try {
    const queueData = {
      timestamp: new Date().toISOString(),
      update: update,
      source: "edge-function",
      priority: determinePriority(update.message?.text)
    };

    // Add to Redis queue for n8n to process
    await redis.lpush("telegram:queue", JSON.stringify(queueData));

    // Set expiry to prevent queue bloat (24 hours)
    await redis.expire("telegram:queue", 86400);

    timer.checkpoint("Queued to Redis");
  } catch (error) {
    console.error("Queue error (non-blocking):", error);
    // Don't throw - this is non-critical path
  }
}

// Determine message priority for queue ordering
function determinePriority(text: string): "high" | "normal" | "low" {
  if (!text) return "normal";

  // High priority keywords
  const highPriority = ["urgent", "emergency", "critical", "asap", "immediately"];
  const lowPriority = ["test", "debug", "ping"];

  const lowerText = text.toLowerCase();

  if (highPriority.some(keyword => lowerText.includes(keyword))) {
    return "high";
  }

  if (lowPriority.some(keyword => lowerText.includes(keyword))) {
    return "low";
  }

  return "normal";
}

// Log to Supabase for analytics
async function logToSupabase(update: any, responseTime: number): Promise<void> {
  try {
    await supabase.from("telegram_webhook_logs").insert({
      message_id: update.message?.message_id,
      chat_id: update.message?.chat?.id,
      user_id: update.message?.from?.id,
      text: update.message?.text?.substring(0, 100), // Truncate for privacy
      response_time_ms: responseTime,
      processed_by: "edge-function",
      created_at: new Date().toISOString()
    });
  } catch (error) {
    console.error("Logging error (non-blocking):", error);
  }
}
```

### 2. Webhook Configuration

#### Set Telegram Webhook to Edge Function

```bash
# Get your Edge Function URL from Supabase Dashboard
EDGE_FUNCTION_URL="https://YOUR_PROJECT.supabase.co/functions/v1/telegram-webhook"

# Set webhook with secret token for security
curl -X POST "https://api.telegram.org/bot${BOT_TOKEN}/setWebhook" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "'${EDGE_FUNCTION_URL}'",
    "secret_token": "'${WEBHOOK_SECRET}'",
    "allowed_updates": ["message", "callback_query", "inline_query"],
    "drop_pending_updates": true
  }'
```

### 3. n8n Queue Consumer Workflow

#### Redis Queue Consumer (n8n Workflow)

```json
{
  "name": "Telegram Queue Processor",
  "nodes": [
    {
      "name": "Redis Trigger",
      "type": "n8n-nodes-base.redisTrigger",
      "parameters": {
        "operation": "list",
        "key": "telegram:queue",
        "options": {
          "blockTime": 5
        }
      },
      "position": [250, 300]
    },
    {
      "name": "Parse Message",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": "const data = JSON.parse($input.item.json.message);\nconst priority = data.priority || 'normal';\n\n// Route based on priority\nif (priority === 'high') {\n  $input.item.route = 'express';\n} else {\n  $input.item.route = 'standard';\n}\n\nreturn $input.item;"
      },
      "position": [450, 300]
    },
    {
      "name": "Process with OpenAI",
      "type": "n8n-nodes-base.openAi",
      "parameters": {
        "operation": "chat",
        "model": "gpt-4-turbo-preview",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "Parse this Telegram message into a structured task"
            },
            {
              "role": "user",
              "content": "={{$json.update.message.text}}"
            }
          ]
        }
      },
      "position": [650, 300]
    }
  ]
}
```

### 4. Environment Configuration

#### Supabase Secrets Configuration

```bash
# Set secrets for Edge Function
supabase secrets set TELEGRAM_BOT_TOKEN="7742923819:AAFjSv7DEOCC8oFRwhhvAjH_EEo8uhe7JK8"
supabase secrets set TELEGRAM_WEBHOOK_SECRET="your-secure-webhook-secret"
supabase secrets set REDIS_URL="redis://default:password@your-redis-host:6379"
```

#### Redis Setup for Queue

```yaml
# docker-compose.yml addition
redis:
  image: redis:7-alpine
  restart: unless-stopped
  ports:
    - "6379:6379"
  volumes:
    - redis_data:/data
  command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
```

### 5. Monitoring and Observability

#### Performance Monitoring Table

```sql
-- Create table for performance tracking
CREATE TABLE telegram_webhook_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  message_id BIGINT,
  chat_id BIGINT,
  user_id BIGINT,
  text TEXT,
  response_time_ms INTEGER,
  processed_by VARCHAR(50),
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for performance queries
CREATE INDEX idx_webhook_logs_response_time ON telegram_webhook_logs(response_time_ms);
CREATE INDEX idx_webhook_logs_created ON telegram_webhook_logs(created_at DESC);

-- View for monitoring dashboard
CREATE VIEW webhook_performance_stats AS
SELECT
  DATE_TRUNC('minute', created_at) as minute,
  AVG(response_time_ms) as avg_response_ms,
  PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms) as p95_response_ms,
  PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY response_time_ms) as p99_response_ms,
  COUNT(*) as request_count
FROM telegram_webhook_logs
WHERE created_at > NOW() - INTERVAL '1 hour'
GROUP BY DATE_TRUNC('minute', created_at)
ORDER BY minute DESC;
```

## Testing Requirements

### Performance Testing

```bash
# Load test with Apache Bench
ab -n 1000 -c 10 -T application/json \
  -p telegram_payload.json \
  -H "X-Telegram-Bot-Api-Secret-Token: your-secret" \
  https://your-project.supabase.co/functions/v1/telegram-webhook

# Expected results:
# - P95 < 200ms
# - P99 < 500ms
# - 0% error rate
```

### Integration Testing

- [ ] Test with valid Telegram webhook payload
- [ ] Test with invalid signature (should reject)
- [ ] Test with malformed JSON (should handle gracefully)
- [ ] Test Redis queue overflow scenario
- [ ] Test n8n consumer processing

## Architecture Benefits

### Why Edge Functions + n8n Queue?

1. **Immediate Response**: Edge Functions provide <200ms responses
2. **Complex Processing**: n8n handles NLP, database operations, integrations
3. **Scalability**: Queue pattern prevents overwhelming n8n
4. **Reliability**: Messages queued even if n8n is temporarily down
5. **Cost Efficiency**: Edge Functions bill per request, n8n runs continuously

### Performance Comparison

| Operation | Direct n8n | Edge + Queue |
|-----------|------------|--------------|
| Acknowledgment | 200-800ms | 50-200ms |
| Full Processing | 500-2000ms | 50-200ms (ack) + async |
| Timeout Risk | Medium | Near Zero |
| Scalability | Limited | High |

## Dependencies

- Supabase project with Edge Functions enabled
- Redis instance for queue management
- n8n instance in queue mode
- Telegram Bot API token
- Cloudflare Tunnel for secure webhook delivery

## Definition of Done

- [ ] Edge Function deployed and responding < 200ms
- [ ] Redis queue operational with n8n consumer
- [ ] Monitoring dashboard showing performance metrics
- [ ] Zero message loss over 24-hour test period
- [ ] Documentation updated with deployment instructions
- [ ] Team trained on monitoring and troubleshooting

## References

- [Supabase Edge Functions Guide](https://supabase.com/docs/guides/functions)
- [grammY Telegram Bot Framework](https://grammy.dev/hosting/supabase)
- [n8n Queue Mode Documentation](https://docs.n8n.io/hosting/scaling/queue-mode/)
- [Telegram Bot Webhook Guide](https://core.telegram.org/bots/webhooks)
- [Redis Queue Patterns](https://redis.io/docs/manual/patterns/reliability/)

---

*Story follows BMAD framework v5 standards*
*Created for Sprint 1 - Infrastructure Foundation*
