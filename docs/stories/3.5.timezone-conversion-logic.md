# Story 3.5: Timezone Conversion Logic

## Overview
Implement comprehensive timezone handling across all FLRTS components, ensuring users see times in their local timezone while maintaining data consistency in UTC.

## Context
- **Epic**: Epic 3 - OpenProject Integration
- **Priority**: P1 (Important for UX)
- **Dependencies**:
  - Story 1.1 (Supabase project setup) - COMPLETED
  - Story 2.6 (Telegram user context) - Required for user preferences
  - Story 3.1 (OpenProject API workflows) - Required for task scheduling
- **Blocks**: Story 4.1, 4.2 (Reminder features need accurate timezone handling)

## Technical Requirements

### Core Timezone Architecture
```typescript
// Timezone configuration
interface TimezoneConfig {
  DATABASE_TIMEZONE: 'UTC';           // Always store in UTC
  DEFAULT_USER_TIMEZONE: string;      // Fallback: 'America/New_York'
  SUPPORTED_TIMEZONES: string[];      // IANA timezone list
  AUTO_DETECT: boolean;               // Attempt automatic detection
  DST_HANDLING: 'automatic' | 'manual';
}

// User timezone context
interface UserTimezoneContext {
  userId: string;
  timezone: string;                   // IANA timezone identifier
  offset: number;                     // Current UTC offset in minutes
  isDST: boolean;                    // Currently in DST
  locale?: string;                   // User's locale for formatting
  format24Hour: boolean;             // Time format preference
  weekStartsOn: 0 | 1 | 6;          // Sunday, Monday, or Saturday
}
```

### PostgreSQL Timezone Handling
```sql
-- Store all timestamps as TIMESTAMPTZ (UTC internally)
CREATE TABLE user_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  title TEXT NOT NULL,
  due_at TIMESTAMPTZ,          -- Stored as UTC
  reminder_at TIMESTAMPTZ,      -- Stored as UTC
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- User timezone preferences
CREATE TABLE user_timezones (
  user_id UUID PRIMARY KEY,
  timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',
  format_24hour BOOLEAN DEFAULT false,
  week_starts_on SMALLINT DEFAULT 1, -- Monday
  locale VARCHAR(10) DEFAULT 'en-US',
  auto_detect BOOLEAN DEFAULT true,
  last_detected_at TIMESTAMPTZ,
  CONSTRAINT valid_timezone CHECK (
    timezone IN (SELECT name FROM pg_timezone_names)
  )
);

-- Function to convert UTC to user's timezone
CREATE OR REPLACE FUNCTION convert_to_user_tz(
  utc_time TIMESTAMPTZ,
  user_tz TEXT
) RETURNS TIMESTAMP AS $$
BEGIN
  RETURN utc_time AT TIME ZONE user_tz;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- View with user-local times
CREATE VIEW user_tasks_localized AS
SELECT
  t.id,
  t.user_id,
  t.title,
  t.due_at AS due_at_utc,
  convert_to_user_tz(t.due_at, COALESCE(u.timezone, 'UTC')) AS due_at_local,
  convert_to_user_tz(t.reminder_at, COALESCE(u.timezone, 'UTC')) AS reminder_at_local,
  u.timezone AS user_timezone
FROM user_tasks t
LEFT JOIN user_timezones u ON t.user_id = u.user_id;
```

### JavaScript Temporal API Implementation
```typescript
import { Temporal } from '@js-temporal/polyfill';

class TimezoneManager {
  /**
   * Convert UTC timestamp to user's local time using Temporal API
   */
  static toUserTime(
    utcTimestamp: string,
    userTimezone: string
  ): Temporal.ZonedDateTime {
    // Parse UTC timestamp
    const instant = Temporal.Instant.from(utcTimestamp);

    // Convert to user's timezone
    const userZonedDateTime = instant.toZonedDateTimeISO(userTimezone);

    return userZonedDateTime;
  }

  /**
   * Convert user input to UTC for storage
   */
  static toUTC(
    localDateTime: string,
    userTimezone: string
  ): Temporal.Instant {
    // Parse user's local time
    const zonedDateTime = Temporal.ZonedDateTime.from({
      timeZone: userTimezone,
      year: parseInt(localDateTime.substring(0, 4)),
      month: parseInt(localDateTime.substring(5, 7)),
      day: parseInt(localDateTime.substring(8, 10)),
      hour: parseInt(localDateTime.substring(11, 13)),
      minute: parseInt(localDateTime.substring(14, 16)),
      second: 0,
      millisecond: 0,
      microsecond: 0,
      nanosecond: 0
    });

    // Convert to UTC instant
    return zonedDateTime.toInstant();
  }

  /**
   * Calculate next occurrence considering DST transitions
   */
  static calculateNextOccurrence(
    baseTime: Temporal.ZonedDateTime,
    pattern: RecurrencePattern
  ): Temporal.ZonedDateTime {
    let next = baseTime;

    switch (pattern.type) {
      case 'daily':
        // Add days maintaining wall clock time
        next = next.add({ days: pattern.interval });
        break;

      case 'weekly':
        next = next.add({ weeks: pattern.interval });
        break;

      case 'monthly':
        // Handle month-end edge cases
        const targetDay = Math.min(
          baseTime.day,
          next.with({ month: next.month + pattern.interval }).daysInMonth
        );
        next = next.with({
          month: next.month + pattern.interval,
          day: targetDay
        });
        break;
    }

    // Handle DST transitions
    if (this.isDSTTransition(baseTime, next)) {
      next = this.adjustForDST(next, userTimezone);
    }

    return next;
  }

  /**
   * Detect DST transitions
   */
  private static isDSTTransition(
    before: Temporal.ZonedDateTime,
    after: Temporal.ZonedDateTime
  ): boolean {
    return before.offsetNanoseconds !== after.offsetNanoseconds;
  }
}
```

### Telegram Bot Timezone Detection
```typescript
import { Context } from 'grammy';
import { getTimezone } from 'countries-and-timezones';

class TelegramTimezoneDetector {
  /**
   * Attempt to detect user's timezone from Telegram data
   */
  static async detectTimezone(ctx: Context): Promise<string | null> {
    // Method 1: Check user's language code for hints
    const languageCode = ctx.from?.language_code;
    if (languageCode) {
      const timezone = this.getTimezoneFromLanguage(languageCode);
      if (timezone) return timezone;
    }

    // Method 2: Ask user to share location (one-time)
    if (ctx.message?.location) {
      const { latitude, longitude } = ctx.message.location;
      return await this.getTimezoneFromCoordinates(latitude, longitude);
    }

    // Method 3: Interactive timezone selection
    return null; // Fallback to manual selection
  }

  /**
   * Convert coordinates to timezone using geo-tz library
   */
  private static async getTimezoneFromCoordinates(
    lat: number,
    lon: number
  ): Promise<string> {
    const geoTz = await import('geo-tz');
    const timezones = geoTz.find(lat, lon);
    return timezones[0] || 'UTC';
  }

  /**
   * Smart timezone picker with common zones first
   */
  static async promptTimezoneSelection(ctx: Context): Promise<void> {
    const commonTimezones = [
      { name: 'New York (EST/EDT)', tz: 'America/New_York' },
      { name: 'Chicago (CST/CDT)', tz: 'America/Chicago' },
      { name: 'Denver (MST/MDT)', tz: 'America/Denver' },
      { name: 'Los Angeles (PST/PDT)', tz: 'America/Los_Angeles' },
      { name: 'London (GMT/BST)', tz: 'Europe/London' },
      { name: 'Paris (CET/CEST)', tz: 'Europe/Paris' },
      { name: 'Dubai (GST)', tz: 'Asia/Dubai' },
      { name: 'Singapore (SGT)', tz: 'Asia/Singapore' },
      { name: 'Tokyo (JST)', tz: 'Asia/Tokyo' },
      { name: 'Sydney (AEST/AEDT)', tz: 'Australia/Sydney' }
    ];

    const keyboard = {
      inline_keyboard: [
        ...commonTimezones.map(tz => [{
          text: tz.name,
          callback_data: `tz_set:${tz.tz}`
        }]),
        [{ text: '🌍 More timezones...', callback_data: 'tz_more' }],
        [{ text: '📍 Share location', callback_data: 'tz_location' }]
      ]
    };

    await ctx.reply(
      '🕐 Please select your timezone:\n\n' +
      'This helps me show you times in your local timezone.',
      { reply_markup: keyboard }
    );
  }
}
```

### Natural Language Time Parsing with Timezone Awareness
```typescript
import * as chrono from 'chrono-node';
import { Temporal } from '@js-temporal/polyfill';

class TimezoneAwareParser {
  private userTimezone: string;
  private currentTime: Temporal.ZonedDateTime;

  constructor(userTimezone: string) {
    this.userTimezone = userTimezone;
    this.currentTime = Temporal.Now.zonedDateTimeISO(userTimezone);
  }

  /**
   * Parse natural language with timezone context
   */
  parseDateTime(input: string): Temporal.ZonedDateTime | null {
    // Configure chrono with user's timezone
    const customChrono = chrono.casual.clone();
    customChrono.refiners.push({
      refine: (context, results) => {
        results.forEach(result => {
          // Apply user's timezone to ambiguous times
          if (!result.start.isCertain('timezoneOffset')) {
            const offset = this.currentTime.offsetNanoseconds / 1_000_000_000 / 60;
            result.start.assign('timezoneOffset', offset);
          }
        });
        return results;
      }
    });

    // Parse with reference time in user's timezone
    const referenceDate = new Date(this.currentTime.epochMilliseconds);
    const parsed = customChrono.parseDate(input, referenceDate);

    if (!parsed) return null;

    // Convert to Temporal.ZonedDateTime
    return Temporal.ZonedDateTime.from({
      timeZone: this.userTimezone,
      year: parsed.getFullYear(),
      month: parsed.getMonth() + 1,
      day: parsed.getDate(),
      hour: parsed.getHours(),
      minute: parsed.getMinutes(),
      second: parsed.getSeconds()
    });
  }

  /**
   * Format datetime for user display
   */
  formatForUser(
    zonedDateTime: Temporal.ZonedDateTime,
    options: FormatOptions = {}
  ): string {
    const {
      includeDate = true,
      includeTime = true,
      includeTimezone = false,
      relative = false,
      format24Hour = false
    } = options;

    if (relative) {
      return this.getRelativeTime(zonedDateTime);
    }

    const formatter = new Intl.DateTimeFormat(options.locale || 'en-US', {
      timeZone: this.userTimezone,
      ...(includeDate && {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      }),
      ...(includeTime && {
        hour: format24Hour ? '2-digit' : 'numeric',
        minute: '2-digit',
        hour12: !format24Hour
      }),
      ...(includeTimezone && {
        timeZoneName: 'short'
      })
    });

    return formatter.format(new Date(zonedDateTime.epochMilliseconds));
  }

  /**
   * Get relative time description
   */
  private getRelativeTime(target: Temporal.ZonedDateTime): string {
    const duration = this.currentTime.until(target);

    const totalMinutes = duration.total('minutes');
    const totalHours = duration.total('hours');
    const totalDays = duration.total('days');

    if (Math.abs(totalMinutes) < 1) return 'now';
    if (Math.abs(totalMinutes) < 60) {
      return `${Math.round(totalMinutes)} minute${Math.abs(totalMinutes) !== 1 ? 's' : ''} ${totalMinutes > 0 ? 'from now' : 'ago'}`;
    }
    if (Math.abs(totalHours) < 24) {
      return `${Math.round(totalHours)} hour${Math.abs(totalHours) !== 1 ? 's' : ''} ${totalHours > 0 ? 'from now' : 'ago'}`;
    }
    if (Math.abs(totalDays) < 7) {
      return `${Math.round(totalDays)} day${Math.abs(totalDays) !== 1 ? 's' : ''} ${totalDays > 0 ? 'from now' : 'ago'}`;
    }

    // Fall back to absolute date for longer periods
    return this.formatForUser(target, { includeTime: false });
  }
}
```

### Recurring Events with DST Handling
```typescript
interface RecurrenceRule {
  frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
  interval: number;
  daysOfWeek?: number[]; // 0 = Sunday, 6 = Saturday
  dayOfMonth?: number;
  monthOfYear?: number;
  timeOfDay: { hour: number; minute: number };
  preserveLocalTime: boolean; // Maintain wall clock time across DST
}

class RecurrenceCalculator {
  /**
   * Calculate all occurrences within a date range
   */
  static calculateOccurrences(
    rule: RecurrenceRule,
    startDate: Temporal.ZonedDateTime,
    endDate: Temporal.ZonedDateTime,
    timezone: string
  ): Temporal.ZonedDateTime[] {
    const occurrences: Temporal.ZonedDateTime[] = [];
    let current = startDate;

    while (Temporal.ZonedDateTime.compare(current, endDate) <= 0) {
      // Calculate next occurrence
      current = this.getNextOccurrence(current, rule, timezone);

      if (Temporal.ZonedDateTime.compare(current, endDate) <= 0) {
        occurrences.push(current);
      }
    }

    return occurrences;
  }

  /**
   * Get next occurrence handling DST transitions
   */
  private static getNextOccurrence(
    from: Temporal.ZonedDateTime,
    rule: RecurrenceRule,
    timezone: string
  ): Temporal.ZonedDateTime {
    let next: Temporal.ZonedDateTime;

    if (rule.preserveLocalTime) {
      // Maintain wall clock time (e.g., 9 AM stays 9 AM after DST)
      const localTime = from.toPlainDateTime();

      switch (rule.frequency) {
        case 'daily':
          next = from.add({ days: rule.interval }).with({
            hour: rule.timeOfDay.hour,
            minute: rule.timeOfDay.minute
          });
          break;

        case 'weekly':
          next = from.add({ weeks: rule.interval }).with({
            hour: rule.timeOfDay.hour,
            minute: rule.timeOfDay.minute
          });
          break;

        case 'monthly':
          // Handle month-end edge cases
          const targetMonth = from.month + rule.interval;
          const targetYear = from.year + Math.floor(targetMonth / 12);
          const normalizedMonth = ((targetMonth - 1) % 12) + 1;

          next = Temporal.ZonedDateTime.from({
            timeZone: timezone,
            year: targetYear,
            month: normalizedMonth,
            day: Math.min(rule.dayOfMonth || from.day,
                         this.getDaysInMonth(targetYear, normalizedMonth)),
            hour: rule.timeOfDay.hour,
            minute: rule.timeOfDay.minute
          });
          break;
      }
    } else {
      // Maintain exact duration (e.g., every 24 hours exactly)
      next = from.add({ [`${rule.frequency}s`]: rule.interval });
    }

    return next;
  }

  private static getDaysInMonth(year: number, month: number): number {
    return new Temporal.PlainYearMonth(year, month).daysInMonth;
  }
}
```

### n8n Timezone Workflow
```json
{
  "name": "Timezone Handler",
  "nodes": [
    {
      "type": "n8n-nodes-base.function",
      "name": "Convert Times",
      "parameters": {
        "functionCode": `
          const { Temporal } = require('@js-temporal/polyfill');

          // Get user's timezone from database
          const userTimezone = $input.item.json.userTimezone || 'UTC';

          // Convert stored UTC time to user's local time
          const utcTime = $input.item.json.reminderTimeUTC;
          const instant = Temporal.Instant.from(utcTime);
          const userTime = instant.toZonedDateTimeISO(userTimezone);

          // Format for display
          const formatter = new Intl.DateTimeFormat('en-US', {
            timeZone: userTimezone,
            dateStyle: 'medium',
            timeStyle: 'short'
          });

          return {
            json: {
              utcTime,
              localTime: userTime.toString(),
              formatted: formatter.format(new Date(instant.epochMilliseconds)),
              timezone: userTimezone,
              offset: userTime.offsetNanoseconds / 1_000_000_000 / 3600
            }
          };
        `
      }
    },
    {
      "type": "n8n-nodes-base.postgres",
      "name": "Store with Timezone",
      "parameters": {
        "operation": "executeQuery",
        "query": `
          INSERT INTO user_reminders (
            user_id,
            reminder_text,
            reminder_at_utc,
            user_timezone,
            local_hour,
            local_minute
          ) VALUES (
            $1, $2, $3::timestamptz, $4,
            EXTRACT(HOUR FROM $3::timestamptz AT TIME ZONE $4),
            EXTRACT(MINUTE FROM $3::timestamptz AT TIME ZONE $4)
          )
          RETURNING *,
            reminder_at_utc AT TIME ZONE user_timezone AS local_time
        `,
        "additionalFields": {
          "queryParams": "={{$json.params}}"
        }
      }
    }
  ]
}
```

## Implementation Checklist

### Phase 1: Database Setup
- [ ] Configure PostgreSQL with TIMESTAMPTZ columns
- [ ] Create user timezone preferences table
- [ ] Implement timezone conversion functions
- [ ] Add timezone validation constraints

### Phase 2: Core Timezone Logic
- [ ] Integrate Temporal API polyfill
- [ ] Implement TimezoneManager class
- [ ] Add natural language parsing with timezone context
- [ ] Create formatting utilities for different locales

### Phase 3: Telegram Integration
- [ ] Add timezone detection from user data
- [ ] Implement interactive timezone selector
- [ ] Store user timezone preferences
- [ ] Apply timezone to all time displays

### Phase 4: Recurring Events
- [ ] Handle DST transitions correctly
- [ ] Implement wall clock time preservation
- [ ] Add recurrence calculation with timezone awareness
- [ ] Test edge cases (month-end, leap years)

## Testing Requirements

```typescript
describe('Timezone Conversion', () => {
  let timezoneManager: TimezoneManager;

  beforeEach(() => {
    timezoneManager = new TimezoneManager();
  });

  it('should handle DST transitions correctly', () => {
    // Test spring forward (2 AM -> 3 AM)
    const beforeDST = Temporal.ZonedDateTime.from({
      timeZone: 'America/New_York',
      year: 2025,
      month: 3,
      day: 9,
      hour: 1,
      minute: 30
    });

    const afterDST = beforeDST.add({ hours: 1 });
    expect(afterDST.hour).toBe(3); // Should skip 2 AM
    expect(afterDST.minute).toBe(30);
  });

  it('should maintain wall clock time for recurring events', () => {
    const rule: RecurrenceRule = {
      frequency: 'daily',
      interval: 1,
      timeOfDay: { hour: 9, minute: 0 },
      preserveLocalTime: true
    };

    const occurrences = RecurrenceCalculator.calculateOccurrences(
      rule,
      Temporal.ZonedDateTime.from('2025-03-08T09:00[America/New_York]'),
      Temporal.ZonedDateTime.from('2025-03-11T09:00[America/New_York]'),
      'America/New_York'
    );

    // All occurrences should be at 9 AM local time
    occurrences.forEach(occ => {
      expect(occ.hour).toBe(9);
      expect(occ.minute).toBe(0);
    });
  });

  it('should parse natural language with timezone context', () => {
    const parser = new TimezoneAwareParser('Asia/Tokyo');
    const parsed = parser.parseDateTime('tomorrow at 3pm');

    expect(parsed).toBeDefined();
    expect(parsed!.hour).toBe(15);
    expect(parsed!.timeZone.id).toBe('Asia/Tokyo');
  });
});
```

## Performance Specifications
- Timezone conversion: < 5ms per operation
- Batch conversion: 1000+ items per second
- Cache timezone data for 24 hours
- Recurrence calculation: < 50ms for year range
- Format operations: < 10ms per string

## Security Requirements
- Validate all timezone identifiers against IANA database
- Sanitize user locale inputs
- Rate limit timezone detection requests
- Log timezone changes for audit trail
- Never expose internal UTC timestamps to clients

## Developer Resources

### Essential Documentation
```bash
# Temporal API documentation
mcp__ref__ref_search_documentation "JavaScript Temporal API ZonedDateTime timezone handling"

# PostgreSQL timezone functions
mcp__ref__ref_search_documentation "PostgreSQL AT TIME ZONE timestamptz best practices"

# Telegram bot timezone detection
mcp__ref__ref_search_documentation "Telegram bot user location timezone detection"
```

### Debugging Commands
```sql
-- Check user timezone settings
SELECT user_id, timezone,
       NOW() AT TIME ZONE timezone AS local_time
FROM user_timezones;

-- Verify timezone conversions
SELECT
  reminder_at_utc,
  reminder_at_utc AT TIME ZONE 'America/New_York' AS ny_time,
  reminder_at_utc AT TIME ZONE 'Europe/London' AS london_time
FROM user_reminders;

-- List available timezones
SELECT name, abbrev, utc_offset FROM pg_timezone_names
ORDER BY utc_offset;
```

## Acceptance Criteria
1. ✅ All times displayed in user's local timezone
2. ✅ DST transitions handled correctly
3. ✅ Recurring events maintain wall clock time
4. ✅ Natural language parsing respects timezone
5. ✅ Timezone changes update all scheduled items
6. ✅ Performance meets specifications for bulk operations

## Notes for Developers
- Always store times as TIMESTAMPTZ in PostgreSQL
- Use Temporal API for all JavaScript date operations
- Test with timezones that have DST and those that don't
- Consider users who travel across timezones
- Cache timezone data to reduce API calls
- Handle ambiguous times during DST transitions carefully