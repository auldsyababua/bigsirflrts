# Story 3.5: Timezone Conversion Logic

## Overview
Implement comprehensive timezone handling across all FLRTS components, ensuring users see times in their local timezone while maintaining data consistency in UTC.

## Context
- **Epic**: Epic 3 - OpenProject Integration
- **Priority**: P1 (Important for UX)
- **Dependencies**:
  - Story 1.1 (Supabase project setup) - COMPLETED
  - Story 2.6 (Telegram user context) - Required for user preferences
  - Story 3.1 (OpenProject API workflows) - Required for task scheduling
- **Blocks**: Story 4.1, 4.2 (Reminder features need accurate timezone handling)

## Technical Requirements

### Core Timezone Architecture
```typescript
// Timezone configuration
interface TimezoneConfig {
  DATABASE_TIMEZONE: 'UTC';           // Always store in UTC
  DEFAULT_USER_TIMEZONE: string;      // Fallback: 'America/New_York'
  SUPPORTED_TIMEZONES: string[];      // IANA timezone list
  AUTO_DETECT: boolean;               // Attempt automatic detection
  DST_HANDLING: 'automatic' | 'manual';
}

// User timezone context
interface UserTimezoneContext {
  userId: string;
  timezone: string;                   // IANA timezone identifier
  offset: number;                     // Current UTC offset in minutes
  isDST: boolean;                    // Currently in DST
  locale?: string;                   // User's locale for formatting
  format24Hour: boolean;             // Time format preference
  weekStartsOn: 0 | 1 | 6;          // Sunday, Monday, or Saturday
}
```

### PostgreSQL Timezone Handling
```sql
-- Store all timestamps as TIMESTAMPTZ (UTC internally)
CREATE TABLE user_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  title TEXT NOT NULL,
  due_at TIMESTAMPTZ,          -- Stored as UTC
  reminder_at TIMESTAMPTZ,      -- Stored as UTC
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- User timezone preferences
CREATE TABLE user_timezones (
  user_id UUID PRIMARY KEY,
  timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',
  format_24hour BOOLEAN DEFAULT false,
  week_starts_on SMALLINT DEFAULT 1, -- Monday
  locale VARCHAR(10) DEFAULT 'en-US',
  auto_detect BOOLEAN DEFAULT true,
  last_detected_at TIMESTAMPTZ,
  CONSTRAINT valid_timezone CHECK (
    timezone IN (SELECT name FROM pg_timezone_names)
  )
);

-- Function to convert UTC to user's timezone
CREATE OR REPLACE FUNCTION convert_to_user_tz(
  utc_time TIMESTAMPTZ,
  user_tz TEXT
) RETURNS TIMESTAMP AS $$
BEGIN
  RETURN utc_time AT TIME ZONE user_tz;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- View with user-local times
CREATE VIEW user_tasks_localized AS
SELECT
  t.id,
  t.user_id,
  t.title,
  t.due_at AS due_at_utc,
  convert_to_user_tz(t.due_at, COALESCE(u.timezone, 'UTC')) AS due_at_local,
  convert_to_user_tz(t.reminder_at, COALESCE(u.timezone, 'UTC')) AS reminder_at_local,
  u.timezone AS user_timezone
FROM user_tasks t
LEFT JOIN user_timezones u ON t.user_id = u.user_id;
```

### JavaScript Temporal API Implementation
```typescript
import { Temporal } from '@js-temporal/polyfill';

class TimezoneManager {
  /**
   * Convert UTC timestamp to user's local time using Temporal API
   */
  static toUserTime(
    utcTimestamp: string,
    userTimezone: string
  ): Temporal.ZonedDateTime {
    // Parse UTC timestamp
    const instant = Temporal.Instant.from(utcTimestamp);

    // Convert to user's timezone
    const userZonedDateTime = instant.toZonedDateTimeISO(userTimezone);

    return userZonedDateTime;
  }

  /**
   * Convert user input to UTC for storage
   */
  static toUTC(
    localDateTime: string,
    userTimezone: string
  ): Temporal.Instant {
    // Parse user's local time
    const zonedDateTime = Temporal.ZonedDateTime.from({
      timeZone: userTimezone,
      year: parseInt(localDateTime.substring(0, 4)),
      month: parseInt(localDateTime.substring(5, 7)),
      day: parseInt(localDateTime.substring(8, 10)),
      hour: parseInt(localDateTime.substring(11, 13)),
      minute: parseInt(localDateTime.substring(14, 16)),
      second: 0,
      millisecond: 0,
      microsecond: 0,
      nanosecond: 0
    });

    // Convert to UTC instant
    return zonedDateTime.toInstant();
  }

  /**
   * Calculate next occurrence considering DST transitions
   */
  static calculateNextOccurrence(
    baseTime: Temporal.ZonedDateTime,
    pattern: RecurrencePattern
  ): Temporal.ZonedDateTime {
    let next = baseTime;

    switch (pattern.type) {
      case 'daily':
        // Add days maintaining wall clock time
        next = next.add({ days: pattern.interval });
        break;

      case 'weekly':
        next = next.add({ weeks: pattern.interval });
        break;

      case 'monthly':
        // Handle month-end edge cases
        const targetDay = Math.min(
          baseTime.day,
          next.with({ month: next.month + pattern.interval }).daysInMonth
        );
        next = next.with({
          month: next.month + pattern.interval,
          day: targetDay
        });
        break;
    }

    // Handle DST transitions
    if (this.isDSTTransition(baseTime, next)) {
      next = this.adjustForDST(next, userTimezone);
    }

    return next;
  }

  /**
   * Detect DST transitions
   */
  private static isDSTTransition(
    before: Temporal.ZonedDateTime,
    after: Temporal.ZonedDateTime
  ): boolean {
    return before.offsetNanoseconds !== after.offsetNanoseconds;
  }
}
```

### Telegram Bot Timezone Detection
```typescript
import { Context } from 'grammy';
import { getTimezone } from 'countries-and-timezones';

class TelegramTimezoneDetector {
  /**
   * Attempt to detect user's timezone from Telegram data
   */
  static async detectTimezone(ctx: Context): Promise<string | null> {
    // Method 1: Check user's language code for hints
    const languageCode = ctx.from?.language_code;
    if (languageCode) {
      const timezone = this.getTimezoneFromLanguage(languageCode);
      if (timezone) return timezone;
    }

    // Method 2: Ask user to share location (one-time)
    if (ctx.message?.location) {
      const { latitude, longitude } = ctx.message.location;
      return await this.getTimezoneFromCoordinates(latitude, longitude);
    }

    // Method 3: Interactive timezone selection
    return null; // Fallback to manual selection
  }

  /**
   * Convert coordinates to timezone using geo-tz library
   */
  private static async getTimezoneFromCoordinates(
    lat: number,
    lon: number
  ): Promise<string> {
    const geoTz = await import('geo-tz');
    const timezones = geoTz.find(lat, lon);
    return timezones[0] || 'UTC';
  }

  /**
   * Smart timezone picker with common zones first
   */
  static async promptTimezoneSelection(ctx: Context): Promise<void> {
    const commonTimezones = [
      { name: 'New York (EST/EDT)', tz: 'America/New_York' },
      { name: 'Chicago (CST/CDT)', tz: 'America/Chicago' },
      { name: 'Denver (MST/MDT)', tz: 'America/Denver' },
      { name: 'Los Angeles (PST/PDT)', tz: 'America/Los_Angeles' },
      { name: 'London (GMT/BST)', tz: 'Europe/London' },
      { name: 'Paris (CET/CEST)', tz: 'Europe/Paris' },
      { name: 'Dubai (GST)', tz: 'Asia/Dubai' },
      { name: 'Singapore (SGT)', tz: 'Asia/Singapore' },
      { name: 'Tokyo (JST)', tz: 'Asia/Tokyo' },
      { name: 'Sydney (AEST/AEDT)', tz: 'Australia/Sydney' }
    ];

    const keyboard = {
      inline_keyboard: [
        ...commonTimezones.map(tz => [{
          text: tz.name,
          callback_data: `tz_set:${tz.tz}`
        }]),
        [{ text: 'ðŸŒ More timezones...', callback_data: 'tz_more' }],
        [{ text: 'ðŸ“ Share location', callback_data: 'tz_location' }]
      ]
    };

    await ctx.reply(
      'ðŸ• Please select your timezone:\n\n' +
      'This helps me show you times in your local timezone.',
      { reply_markup: keyboard }
    );
  }
}
```

### Natural Language Time Parsing with Timezone Awareness
```typescript
import * as chrono from 'chrono-node';
import { Temporal } from '@js-temporal/polyfill';

class TimezoneAwareParser {
  private userTimezone: string;
  private currentTime: Temporal.ZonedDateTime;

  constructor(userTimezone: string) {
    this.userTimezone = userTimezone;
    this.currentTime = Temporal.Now.zonedDateTimeISO(userTimezone);
  }

  /**
   * Parse natural language with timezone context
   */
  parseDateTime(input: string): Temporal.ZonedDateTime | null {
    // Configure chrono with user's timezone
    const customChrono = chrono.casual.clone();
    customChrono.refiners.push({
      refine: (context, results) => {
        results.forEach(result => {
          // Apply user's timezone to ambiguous times
          if (!result.start.isCertain('timezoneOffset')) {
            const offset = this.currentTime.offsetNanoseconds / 1_000_000_000 / 60;
            result.start.assign('timezoneOffset', offset);
          }
        });
        return results;
      }
    });

    // Parse with reference time in user's timezone
    const referenceDate = new Date(this.currentTime.epochMilliseconds);
    const parsed = customChrono.parseDate(input, referenceDate);

    if (!parsed) return null;

    // Convert to Temporal.ZonedDateTime
    return Temporal.ZonedDateTime.from({
      timeZone: this.userTimezone,
      year: parsed.getFullYear(),
      month: parsed.getMonth() + 1,
      day: parsed.getDate(),
      hour: parsed.getHours(),
      minute: parsed.getMinutes(),
      second: parsed.getSeconds()
    });
  }

  /**
   * Format datetime for user display
   */
  formatForUser(
    zonedDateTime: Temporal.ZonedDateTime,
    options: FormatOptions = {}
  ): string {
    const {
      includeDate = true,
      includeTime = true,
      includeTimezone = false,
      relative = false,
      format24Hour = false
    } = options;

    if (relative) {
      return this.getRelativeTime(zonedDateTime);
    }

    const formatter = new Intl.DateTimeFormat(options.locale || 'en-US', {
      timeZone: this.userTimezone,
      ...(includeDate && {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      }),
      ...(includeTime && {
        hour: format24Hour ? '2-digit' : 'numeric',
        minute: '2-digit',
        hour12: !format24Hour
      }),
      ...(includeTimezone && {
        timeZoneName: 'short'
      })
    });

    return formatter.format(new Date(zonedDateTime.epochMilliseconds));
  }

  /**
   * Get relative time description
   */
  private getRelativeTime(target: Temporal.ZonedDateTime): string {
    const duration = this.currentTime.until(target);

    const totalMinutes = duration.total('minutes');
    const totalHours = duration.total('hours');
    const totalDays = duration.total('days');

    if (Math.abs(totalMinutes) < 1) return 'now';
    if (Math.abs(totalMinutes) < 60) {
      return `${Math.round(totalMinutes)} minute${Math.abs(totalMinutes) !== 1 ? 's' : ''} ${totalMinutes > 0 ? 'from now' : 'ago'}`;
    }
    if (Math.abs(totalHours) < 24) {
      return `${Math.round(totalHours)} hour${Math.abs(totalHours) !== 1 ? 's' : ''} ${totalHours > 0 ? 'from now' : 'ago'}`;
    }
    if (Math.abs(totalDays) < 7) {
      return `${Math.round(totalDays)} day${Math.abs(totalDays) !== 1 ? 's' : ''} ${totalDays > 0 ? 'from now' : 'ago'}`;
    }

    // Fall back to absolute date for longer periods
    return this.formatForUser(target, { includeTime: false });
  }
}
```

### Recurring Events with DST Handling
```typescript
interface RecurrenceRule {
  frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
  interval: number;
  daysOfWeek?: number[]; // 0 = Sunday, 6 = Saturday
  dayOfMonth?: number;
  monthOfYear?: number;
  timeOfDay: { hour: number; minute: number };
  preserveLocalTime: boolean; // Maintain wall clock time across DST
}

class RecurrenceCalculator {
  /**
   * Calculate all occurrences within a date range
   */
  static calculateOccurrences(
    rule: RecurrenceRule,
    startDate: Temporal.ZonedDateTime,
    endDate: Temporal.ZonedDateTime,
    timezone: string
  ): Temporal.ZonedDateTime[] {
    const occurrences: Temporal.ZonedDateTime[] = [];
    let current = startDate;

    while (Temporal.ZonedDateTime.compare(current, endDate) <= 0) {
      // Calculate next occurrence
      current = this.getNextOccurrence(current, rule, timezone);

      if (Temporal.ZonedDateTime.compare(current, endDate) <= 0) {
        occurrences.push(current);
      }
    }

    return occurrences;
  }

  /**
   * Get next occurrence handling DST transitions
   */
  private static getNextOccurrence(
    from: Temporal.ZonedDateTime,
    rule: RecurrenceRule,
    timezone: string
  ): Temporal.ZonedDateTime {
    let next: Temporal.ZonedDateTime;

    if (rule.preserveLocalTime) {
      // Maintain wall clock time (e.g., 9 AM stays 9 AM after DST)
      const localTime = from.toPlainDateTime();

      switch (rule.frequency) {
        case 'daily':
          next = from.add({ days: rule.interval }).with({
            hour: rule.timeOfDay.hour,
            minute: rule.timeOfDay.minute
          });
          break;

        case 'weekly':
          next = from.add({ weeks: rule.interval }).with({
            hour: rule.timeOfDay.hour,
            minute: rule.timeOfDay.minute
          });
          break;

        case 'monthly':
          // Handle month-end edge cases
          const targetMonth = from.month + rule.interval;
          const targetYear = from.year + Math.floor(targetMonth / 12);
          const normalizedMonth = ((targetMonth - 1) % 12) + 1;

          next = Temporal.ZonedDateTime.from({
            timeZone: timezone,
            year: targetYear,
            month: normalizedMonth,
            day: Math.min(rule.dayOfMonth || from.day,
                         this.getDaysInMonth(targetYear, normalizedMonth)),
            hour: rule.timeOfDay.hour,
            minute: rule.timeOfDay.minute
          });
          break;
      }
    } else {
      // Maintain exact duration (e.g., every 24 hours exactly)
      next = from.add({ [`${rule.frequency}s`]: rule.interval });
    }

    return next;
  }

  private static getDaysInMonth(year: number, month: number): number {
    return new Temporal.PlainYearMonth(year, month).daysInMonth;
  }
}
```

### n8n Timezone Workflow
```json
{
  "name": "Timezone Handler",
  "nodes": [
    {
      "type": "n8n-nodes-base.function",
      "name": "Convert Times",
      "parameters": {
        "functionCode": `
          const { Temporal } = require('@js-temporal/polyfill');

          // Get user's timezone from database
          const userTimezone = $input.item.json.userTimezone || 'UTC';

          // Convert stored UTC time to user's local time
          const utcTime = $input.item.json.reminderTimeUTC;
          const instant = Temporal.Instant.from(utcTime);
          const userTime = instant.toZonedDateTimeISO(userTimezone);

          // Format for display
          const formatter = new Intl.DateTimeFormat('en-US', {
            timeZone: userTimezone,
            dateStyle: 'medium',
            timeStyle: 'short'
          });

          return {
            json: {
              utcTime,
              localTime: userTime.toString(),
              formatted: formatter.format(new Date(instant.epochMilliseconds)),
              timezone: userTimezone,
              offset: userTime.offsetNanoseconds / 1_000_000_000 / 3600
            }
          };
        `
      }
    },
    {
      "type": "n8n-nodes-base.postgres",
      "name": "Store with Timezone",
      "parameters": {
        "operation": "executeQuery",
        "query": `
          INSERT INTO user_reminders (
            user_id,
            reminder_text,
            reminder_at_utc,
            user_timezone,
            local_hour,
            local_minute
          ) VALUES (
            $1, $2, $3::timestamptz, $4,
            EXTRACT(HOUR FROM $3::timestamptz AT TIME ZONE $4),
            EXTRACT(MINUTE FROM $3::timestamptz AT TIME ZONE $4)
          )
          RETURNING *,
            reminder_at_utc AT TIME ZONE user_timezone AS local_time
        `,
        "additionalFields": {
          "queryParams": "={{$json.params}}"
        }
      }
    }
  ]
}
```

## Implementation Checklist

### Phase 1: Database Setup
- [ ] Configure PostgreSQL with TIMESTAMPTZ columns
- [ ] Create user timezone preferences table
- [ ] Implement timezone conversion functions
- [ ] Add timezone validation constraints

### Phase 2: Core Timezone Logic
- [ ] Integrate Temporal API polyfill
- [ ] Implement TimezoneManager class
- [ ] Add natural language parsing with timezone context
- [ ] Create formatting utilities for different locales

### Phase 3: Telegram Integration
- [ ] Add timezone detection from user data
- [ ] Implement interactive timezone selector
- [ ] Store user timezone preferences
- [ ] Apply timezone to all time displays

### Phase 4: Recurring Events
- [ ] Handle DST transitions correctly
- [ ] Implement wall clock time preservation
- [ ] Add recurrence calculation with timezone awareness
- [ ] Test edge cases (month-end, leap years)

## Testing Requirements

```typescript
describe('Timezone Conversion', () => {
  let timezoneManager: TimezoneManager;

  beforeEach(() => {
    timezoneManager = new TimezoneManager();
  });

  it('should handle DST transitions correctly', () => {
    // Test spring forward (2 AM -> 3 AM)
    const beforeDST = Temporal.ZonedDateTime.from({
      timeZone: 'America/New_York',
      year: 2025,
      month: 3,
      day: 9,
      hour: 1,
      minute: 30
    });

    const afterDST = beforeDST.add({ hours: 1 });
    expect(afterDST.hour).toBe(3); // Should skip 2 AM
    expect(afterDST.minute).toBe(30);
  });

  it('should maintain wall clock time for recurring events', () => {
    const rule: RecurrenceRule = {
      frequency: 'daily',
      interval: 1,
      timeOfDay: { hour: 9, minute: 0 },
      preserveLocalTime: true
    };

    const occurrences = RecurrenceCalculator.calculateOccurrences(
      rule,
      Temporal.ZonedDateTime.from('2025-03-08T09:00[America/New_York]'),
      Temporal.ZonedDateTime.from('2025-03-11T09:00[America/New_York]'),
      'America/New_York'
    );

    // All occurrences should be at 9 AM local time
    occurrences.forEach(occ => {
      expect(occ.hour).toBe(9);
      expect(occ.minute).toBe(0);
    });
  });

  it('should parse natural language with timezone context', () => {
    const parser = new TimezoneAwareParser('Asia/Tokyo');
    const parsed = parser.parseDateTime('tomorrow at 3pm');

    expect(parsed).toBeDefined();
    expect(parsed!.hour).toBe(15);
    expect(parsed!.timeZone.id).toBe('Asia/Tokyo');
  });
});
```

## Performance Specifications
- Timezone conversion: < 5ms per operation
- Batch conversion: 1000+ items per second
- Cache timezone data for 24 hours
- Recurrence calculation: < 50ms for year range
- Format operations: < 10ms per string

## Security Requirements
- Validate all timezone identifiers against IANA database
- Sanitize user locale inputs
- Rate limit timezone detection requests
- Log timezone changes for audit trail
- Never expose internal UTC timestamps to clients

## Developer Resources

### Essential Documentation
```bash
# Temporal API documentation
mcp__ref__ref_search_documentation "JavaScript Temporal API ZonedDateTime timezone handling"

# PostgreSQL timezone functions
mcp__ref__ref_search_documentation "PostgreSQL AT TIME ZONE timestamptz best practices"

# Telegram bot timezone detection
mcp__ref__ref_search_documentation "Telegram bot user location timezone detection"
```

### Debugging Commands
```sql
-- Check user timezone settings
SELECT user_id, timezone,
       NOW() AT TIME ZONE timezone AS local_time
FROM user_timezones;

-- Verify timezone conversions
SELECT
  reminder_at_utc,
  reminder_at_utc AT TIME ZONE 'America/New_York' AS ny_time,
  reminder_at_utc AT TIME ZONE 'Europe/London' AS london_time
FROM user_reminders;

-- List available timezones
SELECT name, abbrev, utc_offset FROM pg_timezone_names
ORDER BY utc_offset;
```

## Acceptance Criteria
1. âœ… All times displayed in user's local timezone
2. âœ… DST transitions handled correctly
3. âœ… Recurring events maintain wall clock time
4. âœ… Natural language parsing respects timezone
5. âœ… Timezone changes update all scheduled items
6. âœ… Performance meets specifications for bulk operations

## Notes for Developers
- Always store times as TIMESTAMPTZ in PostgreSQL
- Use Temporal API for all JavaScript date operations
- Test with timezones that have DST and those that don't
- Consider users who travel across timezones
- Cache timezone data to reduce API calls
- Handle ambiguous times during DST transitions carefully