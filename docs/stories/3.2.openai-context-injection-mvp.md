# Story 3.4: OpenAI Context Injection (MVP Approach)

**Priority:** CRITICAL **Points:** 8 **Status:** Ready for Development **Epic:**
3 - NLP Processing

## User Story

As a **field employee**, I want to **send natural language messages that
correctly identify people, sites, and entities** so that **tasks are created
with accurate assignments without me needing to remember IDs or exact names**.

## Business Value

- Enables natural language task creation without custom parsing
- Reduces errors by providing all valid options to OpenAI
- Simplifies MVP by avoiding complex preprocessing
- Leverages OpenAI's pattern matching capabilities

## Context

For MVP, we're "hardcoding" all valid options directly into the OpenAI prompt
rather than building custom preprocessors. This means OpenAI receives complete
lists of users, sites, contractors, and other entities, allowing it to match
natural language to specific IDs. This approach trades token usage for
development simplicity.

## Acceptance Criteria

### Primary Acceptance Criteria

- [ ] OpenAI prompt includes complete list of all FLRTS users with IDs and
      timezones
- [ ] OpenAI prompt includes complete list of all sites with IDs and aliases
- [ ] OpenAI prompt includes complete list of all contractors/vendors
- [ ] OpenAI prompt includes current UTC timestamp at the top
- [ ] OpenAI correctly matches natural language to provided options
- [ ] System handles timezone conversion based on assignee's timezone

### Technical Acceptance Criteria

- [ ] Prompt dynamically fetches current data from database tables
- [ ] Prompt size stays within OpenAI token limits (consider pagination if
      needed)
- [ ] Response includes matched IDs, not just names
- [ ] Timezone logic correctly interprets "my time" vs assignee's time

### Performance Acceptance Criteria

- [ ] Prompt construction takes <100ms
- [ ] Database queries for options use proper indexing
- [ ] Options are cached for 5 minutes to reduce DB load

## Implementation Guide

### 1. Database Schema Setup

```sql
-- Ensure openproject.users is synced with personnel table
CREATE TABLE IF NOT EXISTS openproject.users (
  id UUID PRIMARY KEY,
  personnel_id UUID REFERENCES public.personnel(id),
  name TEXT NOT NULL,
  email TEXT,
  timezone TEXT DEFAULT 'UTC',
  created_at TIMESTAMP DEFAULT NOW()
);

-- Create indexes for fast lookup
CREATE INDEX idx_users_personnel ON openproject.users(personnel_id);
CREATE INDEX idx_sites_active ON public.sites(active) WHERE active = true;
CREATE INDEX idx_contractors_active ON public.contractors(active) WHERE active = true;

-- Add caching view for prompt context (refreshed every 5 minutes)
CREATE MATERIALIZED VIEW prompt_context_cache AS
WITH users AS (
  SELECT
    u.id,
    p.name,
    p.timezone,
    p.role
  FROM openproject.users u
  JOIN public.personnel p ON u.personnel_id = p.id
  WHERE p.active = true
),
sites AS (
  SELECT
    id,
    name,
    aliases
  FROM public.sites
  WHERE active = true
),
contractors AS (
  SELECT
    id,
    name
  FROM public.contractors
  WHERE active = true
)
SELECT
  json_build_object(
    'users', (SELECT json_agg(users) FROM users),
    'sites', (SELECT json_agg(sites) FROM sites),
    'contractors', (SELECT json_agg(contractors) FROM contractors),
    'cached_at', NOW()
  ) as context_data;

-- Create refresh function for cron job
CREATE OR REPLACE FUNCTION refresh_prompt_context()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY prompt_context_cache;
END;
$$ LANGUAGE plpgsql;
```

### 2. Response Processing with Timezone Conversion

```typescript
import { Temporal } from '@js-temporal/polyfill';

interface OpenAIResponse {
  operation: 'CREATE' | 'READ' | 'UPDATE' | 'ARCHIVE';
  flrt_type: 'TASK' | 'LIST';
  data: {
    assignee_id: string;
    site_id?: string;
    contractor_id?: string;
    due_at: string | null;
    reminder_at: string | null;
    time_context: 'sender_time' | 'assignee_time' | 'absolute';
    assignee_timezone: string;
    task_description: string;
    original_time_reference: string;
  };
  confidence: number;
  parse_rationale: string;
  parse_errors: string[];
}

class ResponseProcessor {
  constructor(private readonly teamTimezones: Map<string, string>) {}

  async processOpenAIResponse(
    response: OpenAIResponse,
    senderTimezone: string
  ): Promise<ProcessedTask> {
    // Handle confidence thresholds
    if (response.confidence < 0.6) {
      throw new LowConfidenceError(
        'Parse confidence too low',
        response.parse_rationale
      );
    }

    // Convert times based on context
    const convertedDueAt = this.convertTime(
      response.data.due_at,
      response.data.time_context,
      senderTimezone,
      response.data.assignee_timezone
    );

    const convertedReminderAt = this.convertTime(
      response.data.reminder_at,
      response.data.time_context,
      senderTimezone,
      response.data.assignee_timezone
    );

    return {
      ...response.data,
      due_at: convertedDueAt,
      reminder_at: convertedReminderAt,
      requires_confirmation: response.confidence < 0.95,
    };
  }

  private convertTime(
    timestamp: string | null,
    timeContext: string,
    senderTimezone: string,
    assigneeTimezone: string
  ): string | null {
    if (!timestamp) return null;

    const sourceTimezone =
      timeContext === 'sender_time' ? senderTimezone : assigneeTimezone;

    // Parse and convert using Temporal API
    const plainDateTime = Temporal.PlainDateTime.from(timestamp);
    const zonedDateTime = plainDateTime.toZonedDateTime(sourceTimezone);

    // Convert to assignee's timezone for storage
    const assigneeZoned = zonedDateTime.withTimeZone(assigneeTimezone);

    return assigneeZoned.toString();
  }
}
```

### 3. Error Handling and Retry Logic

```typescript
class OpenAIClient {
  private maxRetries = 3;
  private retryDelay = 1000;

  async callOpenAI(payload: OpenAIRequestPayload): Promise<OpenAIResponse> {
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        const response = await fetch(
          'https://api.openai.com/v1/chat/completions',
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
            },
            body: JSON.stringify(payload),
          }
        );

        if (response.status === 429) {
          // Rate limited - exponential backoff
          await this.delay(this.retryDelay * Math.pow(2, attempt));
          continue;
        }

        if (!response.ok) {
          throw new Error(`OpenAI API error: ${response.status}`);
        }

        const data = await response.json();
        return JSON.parse(data.choices[0].message.content);
      } catch (error) {
        if (attempt === this.maxRetries) {
          throw new OpenAIError('Max retries exceeded', error);
        }
        await this.delay(this.retryDelay);
      }
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
```

### 2. Prompt Template Structure

```typescript
// Production-ready prompt construction with proper typing
interface PromptContext {
  currentTime: string;
  users: Array<{ id: string; name: string; timezone: string; role: string }>;
  sites: Array<{ id: string; name: string; aliases: string[] }>;
  contractors: Array<{ id: string; name: string }>;
  assignerTimezone: string;
}

const SYSTEM_PROMPT = `You are a task parsing assistant for a distributed team task management system.
Parse natural language commands into structured JSON for task operations.

CRITICAL RULES:
1. Always return valid JSON matching the exact schema provided
2. Identify the operation type: CREATE, READ, UPDATE, or ARCHIVE (never DELETE)
3. Extract all entities mentioned (people, locations, times)
4. Identify time context: sender_time, assignee_time, or absolute
5. Parse relative dates based on sender's current time
6. Return confidence score between 0-1
7. Include parse_rationale: a concise explanation of parsing decisions
8. If parsing fails, return empty data with parse_errors array

TIMEZONE CONTEXT:
- When someone says "my time" or "his/her time", mark time_context appropriately
- Default to sender_time if ambiguous
- "EOD" means 5:00 PM in the respective timezone
- "COB" means 6:00 PM in the respective timezone
- "Morning" means 9:00 AM, "Afternoon" means 2:00 PM

OUTPUT SCHEMA:
{
  "operation": "CREATE|READ|UPDATE|ARCHIVE",
  "flrt_type": "TASK|LIST",
  "data": {
    "assigner": "string",
    "assignee": "string",
    "participants": ["array of strings"],
    "task_description": "string",
    "reminder_at": "ISO-8601 or null",
    "due_at": "ISO-8601 or null",
    "recurrence": "string or null",
    "location": "string or null",
    "assignee_timezone": "string",
    "status": "todo|in_progress|done|archived",
    "original_time_reference": "string",
    "time_context": "sender_time|assignee_time|absolute",
    "work_package_id": "string or null"
  },
  "confidence": number,
  "parse_rationale": "string",
  "parse_errors": ["array of error strings"]
}`;

function buildPromptTemplate(context: PromptContext): string {
  return `
Current UTC Time: ${new Date().toISOString()}

You are parsing a task creation request. Match entities to the provided options.

AVAILABLE USERS:
${users.map(u => `- ${u.name} (ID: ${u.id}, Timezone: ${u.timezone})`).join('\n')}

AVAILABLE SITES:
${sites.map(s => `- ${s.name} (ID: ${s.id}, Aliases: ${s.aliases.join(', ')})`).join('\n')}

AVAILABLE CONTRACTORS:
${contractors.map(c => `- ${c.name} (ID: ${c.id})`).join('\n')}

TIMEZONE RULES:
- All dates/times are in the assignee's timezone by default
- If assigner (message sender) says "my time", use assigner's timezone: ${assignerTimezone}
- Assigner timezone: ${assignerTimezone}
- Convert all times to UTC in your response

USER MESSAGE: "${message}"

Return a JSON object with these fields:
{
  "assignee_id": "UUID of matched user",
  "site_id": "UUID of matched site (if mentioned)",
  "contractor_id": "UUID of matched contractor (if mentioned)",
  "due_date": "ISO 8601 datetime in UTC",
  "reminder_date": "ISO 8601 datetime in UTC (if mentioned)",
  "task_title": "Brief task title",
  "task_description": "Full task details",
  "timezone_context": "whose timezone was used (assignee|sender)",
  "confidence": 0-100
}
`;
```

### 3. n8n Workflow Configuration

#### PostgreSQL Node - Fetch All Valid Options

```json
{
  "type": "nodes-base.postgres",
  "operation": "executeQuery",
  "query": `
    WITH users AS (
      SELECT
        u.id,
        p.name,
        p.timezone,
        p.role
      FROM openproject.users u
      JOIN public.personnel p ON u.personnel_id = p.id
      WHERE p.active = true
    ),
    sites AS (
      SELECT
        id,
        name,
        aliases
      FROM public.sites
      WHERE active = true
    ),
    contractors AS (
      SELECT
        id,
        name
      FROM public.contractors
      WHERE active = true
    )
    SELECT
      json_build_object(
        'users', (SELECT json_agg(users) FROM users),
        'sites', (SELECT json_agg(sites) FROM sites),
        'contractors', (SELECT json_agg(contractors) FROM contractors)
      ) as context_data
  `
}
```

#### Function Node - Assemble Prompt

```javascript
// n8n Function node code
const contextData = $input.first().json.context_data;
const userMessage = $input.first().json.message;
const senderInfo = $input.first().json.sender;

// Build the user prompt with all context
const userPrompt = {
  message: userMessage,
  context: {
    sender: {
      name: senderInfo.name,
      timezone: senderInfo.timezone,
      current_time: new Date().toISOString(),
    },
    team_members: contextData.users.reduce((acc, user) => {
      acc[user.name] = {
        id: user.id,
        timezone: user.timezone,
        role: user.role,
      };
      return acc;
    }, {}),
    sites: contextData.sites.map((site) => ({
      id: site.id,
      name: site.name,
      aliases: site.aliases || [],
    })),
    contractors: contextData.contractors.map((c) => ({
      id: c.id,
      name: c.name,
    })),
    available_projects: contextData.sites.map((s) => s.name),
    supported_operations: ['CREATE', 'READ', 'UPDATE', 'ARCHIVE'],
  },
};

return {
  json: {
    system_prompt: SYSTEM_PROMPT,
    user_prompt: JSON.stringify(userPrompt),
  },
};
```

#### OpenAI Node Configuration

```json
{
  "type": "nodes-base.openAi",
  "resource": "chat",
  "model": "gpt-4o",
  "temperature": 0.3,
  "maxTokens": 2000,
  "messages": [
    {
      "role": "system",
      "content": "={{ $json.system_prompt }}"
    },
    {
      "role": "user",
      "content": "={{ $json.user_prompt }}"
    }
  ],
  "responseFormat": { "type": "json_object" }
}
```

### 4. Example Test Cases

```yaml
test_cases:
  - input:
      'Have Bryan send Mark the invoice for site 3 generator by monday at 3pm'
    expected:
      assignee_id: 'bryan-uuid'
      contractor_id: 'mark-uuid'
      site_id: 'site3-uuid'
      due_date: '2024-12-16T21:00:00Z' # Monday 3pm CST converted to UTC
      timezone_context: 'assignee'

  - input: 'Remind me to check the east field pump tomorrow at 9am my time'
    expected:
      assignee_id: 'sender-uuid'
      site_id: 'east-field-uuid'
      due_date: '2024-12-14T17:00:00Z' # 9am PST converted to UTC
      timezone_context: 'sender'
```

## Dependencies

- Story 1.2: Database schema setup
- Story 3.1: OpenAI integration setup
- Personnel table populated with users
- Sites table populated with locations

## Testing Requirements

- Unit tests for prompt construction
- Integration tests with OpenAI API
- Timezone conversion validation
- Entity matching accuracy tests

## Definition of Done

- [ ] All entity types included in prompts
- [ ] OpenAI successfully matches entities with >90% accuracy
- [ ] Timezone conversions work correctly
- [ ] Prompt stays within token limits
- [ ] Performance benchmarks met

## Post-MVP Enhancements

- Implement `/command` preprocessing to reduce ambiguity
- Add `@mention` preprocessing for explicit user selection
- Create entity caching layer
- Implement fuzzy matching fallbacks

## References

- OpenAI GPT-4 API Documentation: [Research via
  mcp__ref__ref_search_documentation]
- n8n OpenAI Node: [Research via mcp__n8n-cloud__get_node_documentation]
- PostgreSQL JSON Functions: [Research via mcp__ref__ref_search_documentation]
