# Story 2.6: Telegram User Context

## Overview
Implement session management and user context tracking for the Telegram bot, maintaining user state, preferences, and conversation flow across interactions.

## Context
- **Epic**: Epic 2 - Telegram Bot Interface
- **Priority**: P1 (Important but less urgent)
- **Dependencies**:
  - Story 1.6 (Redis Queue) - COMPLETED
  - Story 2.1 (Bot initialization) - In Progress
  - Story 2.5 (Command Parser) - COMPLETED
- **Blocks**: Personalized user experiences and multi-step workflows

## Technical Requirements

### Session Data Structure
```typescript
// User session schema
interface UserSession {
  // User identification
  userId: string;               // Telegram user ID
  chatId: string;              // Current chat ID
  username?: string;           // Telegram username
  firstName: string;           // User's first name
  lastName?: string;           // User's last name
  languageCode: string;        // User's language preference

  // User preferences
  preferences: {
    timezone: string;          // User's timezone (e.g., "America/New_York")
    dateFormat: string;        // Preferred date format
    notificationsEnabled: boolean;
    workingHours: {
      start: string;           // "09:00"
      end: string;             // "17:00"
      days: number[];          // [1,2,3,4,5] (Mon-Fri)
    };
    defaultProject?: string;   // OpenProject default project ID
  };

  // Current context
  context: {
    currentCommand?: string;   // Active command being processed
    currentWorkflow?: string;  // Multi-step workflow ID
    workflowStep?: number;     // Current step in workflow
    workflowData?: any;        // Temporary workflow data
    lastActivity: Date;        // Last interaction timestamp
    messageCount: number;      // Messages in current session
  };

  // Conversation state
  conversation: {
    pendingAction?: {
      type: string;
      data: any;
      expiresAt: Date;
    };
    history: Array<{           // Recent command history
      command: string;
      timestamp: Date;
      success: boolean;
    }>;
  };

  // Feature flags
  features: {
    betaAccess: boolean;
    advancedCommands: boolean;
    apiAccess: boolean;
  };
}
```

### Redis Session Storage Implementation
```typescript
import { Redis } from 'ioredis';
import { Context, MiddlewareFn } from 'grammy';

class RedisSessionStorage {
  private redis: Redis;
  private ttl: number = 86400 * 7; // 7 days default TTL

  constructor(redis: Redis) {
    this.redis = redis;
  }

  async read(key: string): Promise<UserSession | undefined> {
    const data = await this.redis.get(this.getKey(key));
    if (!data) return undefined;

    try {
      return JSON.parse(data);
    } catch (error) {
      console.error(`Failed to parse session for ${key}:`, error);
      return undefined;
    }
  }

  async write(key: string, session: UserSession): Promise<void> {
    const data = JSON.stringify(session);
    await this.redis.setex(this.getKey(key), this.ttl, data);
  }

  async delete(key: string): Promise<void> {
    await this.redis.del(this.getKey(key));
  }

  async has(key: string): Promise<boolean> {
    const exists = await this.redis.exists(this.getKey(key));
    return exists === 1;
  }

  // Touch session to extend TTL
  async touch(key: string): Promise<void> {
    await this.redis.expire(this.getKey(key), this.ttl);
  }

  // Get all active sessions (for analytics)
  async getActiveSessions(pattern: string = '*'): Promise<string[]> {
    return this.redis.keys(`session:${pattern}`);
  }

  private getKey(key: string): string {
    return `session:${key}`;
  }
}

// Session middleware factory
export function createSessionMiddleware(redis: Redis): MiddlewareFn {
  const storage = new RedisSessionStorage(redis);

  return async (ctx, next) => {
    const sessionKey = getSessionKey(ctx);
    if (!sessionKey) {
      return next();
    }

    // Load session
    let session = await storage.read(sessionKey);

    // Initialize new session if needed
    if (!session) {
      session = createNewSession(ctx);
    }

    // Attach session to context
    ctx.session = session;

    // Update last activity
    ctx.session.context.lastActivity = new Date();
    ctx.session.context.messageCount++;

    // Process update
    await next();

    // Save session after processing
    await storage.write(sessionKey, ctx.session);
    await storage.touch(sessionKey);
  };
}

function getSessionKey(ctx: Context): string | null {
  // Use user ID for private chats, chat ID for groups
  if (ctx.from?.id) {
    return `user:${ctx.from.id}`;
  }
  if (ctx.chat?.id) {
    return `chat:${ctx.chat.id}`;
  }
  return null;
}

function createNewSession(ctx: Context): UserSession {
  return {
    userId: ctx.from?.id.toString() || '',
    chatId: ctx.chat?.id.toString() || '',
    username: ctx.from?.username,
    firstName: ctx.from?.first_name || '',
    lastName: ctx.from?.last_name,
    languageCode: ctx.from?.language_code || 'en',
    preferences: {
      timezone: 'UTC',
      dateFormat: 'YYYY-MM-DD',
      notificationsEnabled: true,
      workingHours: {
        start: '09:00',
        end: '17:00',
        days: [1, 2, 3, 4, 5],
      },
    },
    context: {
      lastActivity: new Date(),
      messageCount: 0,
    },
    conversation: {
      history: [],
    },
    features: {
      betaAccess: false,
      advancedCommands: false,
      apiAccess: false,
    },
  };
}
```

### Multi-Step Workflow Management
```typescript
import { Conversation, ConversationFlavor } from '@grammyjs/conversations';

// Workflow registry
interface WorkflowDefinition {
  id: string;
  name: string;
  steps: WorkflowStep[];
  timeout: number; // Timeout in seconds
  onTimeout?: (ctx: Context, session: UserSession) => Promise<void>;
  onCancel?: (ctx: Context, session: UserSession) => Promise<void>;
  onComplete?: (ctx: Context, session: UserSession, data: any) => Promise<void>;
}

interface WorkflowStep {
  id: string;
  prompt: string | ((data: any) => string);
  validator?: (input: string, data: any) => boolean | string;
  transformer?: (input: string, data: any) => any;
  skipCondition?: (data: any) => boolean;
  errorMessage?: string;
}

class WorkflowManager {
  private workflows: Map<string, WorkflowDefinition> = new Map();
  private activeWorkflows: Map<string, NodeJS.Timeout> = new Map();

  register(workflow: WorkflowDefinition) {
    this.workflows.set(workflow.id, workflow);
  }

  async start(
    ctx: Context,
    session: UserSession,
    workflowId: string,
    initialData: any = {}
  ): Promise<void> {
    const workflow = this.workflows.get(workflowId);
    if (!workflow) {
      throw new Error(`Workflow ${workflowId} not found`);
    }

    // Set workflow context
    session.context.currentWorkflow = workflowId;
    session.context.workflowStep = 0;
    session.context.workflowData = initialData;

    // Set timeout
    const timeoutId = setTimeout(() => {
      this.handleTimeout(ctx, session, workflow);
    }, workflow.timeout * 1000);

    this.activeWorkflows.set(session.userId, timeoutId);

    // Start first step
    await this.executeStep(ctx, session, workflow, 0);
  }

  async continue(
    ctx: Context,
    session: UserSession,
    input: string
  ): Promise<void> {
    const workflowId = session.context.currentWorkflow;
    if (!workflowId) {
      await ctx.reply('No active workflow. Start a new task with a command.');
      return;
    }

    const workflow = this.workflows.get(workflowId);
    if (!workflow) {
      session.context.currentWorkflow = undefined;
      await ctx.reply('Workflow expired. Please start again.');
      return;
    }

    const currentStep = session.context.workflowStep || 0;
    const step = workflow.steps[currentStep];

    // Validate input
    if (step.validator) {
      const validationResult = step.validator(input, session.context.workflowData);
      if (typeof validationResult === 'string') {
        await ctx.reply(validationResult);
        return;
      }
      if (!validationResult) {
        await ctx.reply(step.errorMessage || 'Invalid input. Please try again.');
        return;
      }
    }

    // Transform and store input
    if (step.transformer) {
      session.context.workflowData[step.id] = step.transformer(
        input,
        session.context.workflowData
      );
    } else {
      session.context.workflowData[step.id] = input;
    }

    // Move to next step
    const nextStep = currentStep + 1;
    if (nextStep >= workflow.steps.length) {
      // Workflow complete
      await this.complete(ctx, session, workflow);
    } else {
      // Continue to next step
      session.context.workflowStep = nextStep;
      await this.executeStep(ctx, session, workflow, nextStep);
    }
  }

  async cancel(ctx: Context, session: UserSession): Promise<void> {
    const workflowId = session.context.currentWorkflow;
    if (!workflowId) return;

    const workflow = this.workflows.get(workflowId);
    if (workflow?.onCancel) {
      await workflow.onCancel(ctx, session);
    }

    this.clearWorkflow(session);
    await ctx.reply('‚ùå Workflow cancelled.');
  }

  private async executeStep(
    ctx: Context,
    session: UserSession,
    workflow: WorkflowDefinition,
    stepIndex: number
  ): Promise<void> {
    const step = workflow.steps[stepIndex];

    // Check skip condition
    if (step.skipCondition && step.skipCondition(session.context.workflowData)) {
      session.context.workflowStep = stepIndex + 1;
      if (stepIndex + 1 < workflow.steps.length) {
        await this.executeStep(ctx, session, workflow, stepIndex + 1);
      } else {
        await this.complete(ctx, session, workflow);
      }
      return;
    }

    // Send prompt
    const prompt = typeof step.prompt === 'function'
      ? step.prompt(session.context.workflowData)
      : step.prompt;

    await ctx.reply(prompt, {
      reply_markup: {
        inline_keyboard: [[
          { text: '‚ùå Cancel', callback_data: 'workflow:cancel' },
        ]],
      },
    });
  }

  private async complete(
    ctx: Context,
    session: UserSession,
    workflow: WorkflowDefinition
  ): Promise<void> {
    const data = session.context.workflowData;

    // Clear timeout
    const timeoutId = this.activeWorkflows.get(session.userId);
    if (timeoutId) {
      clearTimeout(timeoutId);
      this.activeWorkflows.delete(session.userId);
    }

    // Execute completion handler
    if (workflow.onComplete) {
      await workflow.onComplete(ctx, session, data);
    }

    // Clear workflow context
    this.clearWorkflow(session);

    await ctx.reply('‚úÖ Workflow completed successfully!');
  }

  private async handleTimeout(
    ctx: Context,
    session: UserSession,
    workflow: WorkflowDefinition
  ): Promise<void> {
    if (workflow.onTimeout) {
      await workflow.onTimeout(ctx, session);
    }

    this.clearWorkflow(session);
    this.activeWorkflows.delete(session.userId);

    await ctx.reply('‚è∞ Workflow timed out. Please start again.');
  }

  private clearWorkflow(session: UserSession): void {
    session.context.currentWorkflow = undefined;
    session.context.workflowStep = undefined;
    session.context.workflowData = undefined;
  }
}

// Example workflow: Create task with details
const createTaskWorkflow: WorkflowDefinition = {
  id: 'create-task',
  name: 'Create Task',
  timeout: 300, // 5 minutes
  steps: [
    {
      id: 'title',
      prompt: 'üìù What\'s the task title?',
      validator: (input) => input.length > 0 && input.length <= 100,
      errorMessage: 'Title must be between 1 and 100 characters.',
    },
    {
      id: 'description',
      prompt: 'üìã Add a description (or type "skip"):',
      transformer: (input) => input === 'skip' ? null : input,
    },
    {
      id: 'dueDate',
      prompt: 'üìÖ When is it due? (e.g., "tomorrow at 3pm" or "skip"):',
      transformer: (input, data) => {
        if (input === 'skip') return null;
        return chrono.parseDate(input);
      },
      validator: (input) => {
        if (input === 'skip') return true;
        return chrono.parseDate(input) !== null;
      },
      errorMessage: 'Could not understand the date. Try "tomorrow", "next Monday", etc.',
    },
    {
      id: 'priority',
      prompt: 'üéØ Priority? (high/medium/low):',
      validator: (input) => ['high', 'medium', 'low'].includes(input.toLowerCase()),
      transformer: (input) => input.toLowerCase(),
      errorMessage: 'Please choose: high, medium, or low',
    },
  ],
  onComplete: async (ctx, session, data) => {
    // Queue task creation
    await queueTaskCreation({
      userId: session.userId,
      title: data.title,
      description: data.description,
      dueDate: data.dueDate,
      priority: data.priority,
    });
  },
};
```

### User Preference Management
```typescript
// Preference update commands
bot.command('settings', async (ctx) => {
  const keyboard = {
    inline_keyboard: [
      [{ text: 'üåç Timezone', callback_data: 'pref:timezone' }],
      [{ text: 'üìÖ Date Format', callback_data: 'pref:dateformat' }],
      [{ text: 'üîî Notifications', callback_data: 'pref:notifications' }],
      [{ text: '‚è∞ Working Hours', callback_data: 'pref:workinghours' }],
      [{ text: 'üìÅ Default Project', callback_data: 'pref:project' }],
    ],
  };

  await ctx.reply('‚öôÔ∏è *Settings*\nChoose what to configure:', {
    parse_mode: 'Markdown',
    reply_markup: keyboard,
  });
});

bot.callbackQuery(/^pref:(.+)$/, async (ctx) => {
  const preference = ctx.match[1];
  const session = ctx.session as UserSession;

  switch (preference) {
    case 'timezone':
      await handleTimezoneUpdate(ctx, session);
      break;
    case 'notifications':
      await handleNotificationToggle(ctx, session);
      break;
    // ... other preferences
  }

  await ctx.answerCallbackQuery();
});

async function handleTimezoneUpdate(ctx: Context, session: UserSession) {
  // Common timezones keyboard
  const timezones = [
    ['America/New_York', 'America/Chicago'],
    ['America/Denver', 'America/Los_Angeles'],
    ['Europe/London', 'Europe/Paris'],
    ['Europe/Berlin', 'Asia/Tokyo'],
    ['Asia/Shanghai', 'Australia/Sydney'],
  ];

  const keyboard = {
    inline_keyboard: timezones.map(row =>
      row.map(tz => ({
        text: tz.split('/')[1],
        callback_data: `tz:${tz}`,
      }))
    ),
  };

  await ctx.reply(
    `Current timezone: *${session.preferences.timezone}*\nSelect new timezone:`,
    {
      parse_mode: 'Markdown',
      reply_markup: keyboard,
    }
  );
}

// Timezone selection handler
bot.callbackQuery(/^tz:(.+)$/, async (ctx) => {
  const timezone = ctx.match[1];
  const session = ctx.session as UserSession;

  session.preferences.timezone = timezone;

  await ctx.reply(`‚úÖ Timezone updated to ${timezone}`);
  await ctx.answerCallbackQuery('Timezone updated');
});
```

### Context-Aware Command Handling
```typescript
// Context-aware middleware
async function contextAwareMiddleware(ctx: Context, next: NextFunction) {
  const session = ctx.session as UserSession;

  // Check if there's an active workflow
  if (session?.context.currentWorkflow && ctx.message?.text) {
    const workflowManager = ctx.workflowManager as WorkflowManager;

    // Check for cancel command
    if (ctx.message.text === '/cancel') {
      await workflowManager.cancel(ctx, session);
      return;
    }

    // Continue workflow
    await workflowManager.continue(ctx, session, ctx.message.text);
    return;
  }

  // Check for pending actions
  if (session?.conversation.pendingAction) {
    const action = session.conversation.pendingAction;

    // Check if action expired
    if (new Date() > action.expiresAt) {
      session.conversation.pendingAction = undefined;
      await ctx.reply('‚è∞ Previous action expired. Please start again.');
      return next();
    }

    // Process pending action
    await processPendingAction(ctx, action, ctx.message?.text || '');
    session.conversation.pendingAction = undefined;
    return;
  }

  return next();
}

bot.use(contextAwareMiddleware);
```

### Session Analytics & Monitoring
```typescript
class SessionAnalytics {
  private redis: Redis;

  constructor(redis: Redis) {
    this.redis = redis;
  }

  async trackCommand(userId: string, command: string, success: boolean) {
    const key = `analytics:commands:${userId}`;
    const data = {
      command,
      timestamp: Date.now(),
      success,
    };

    await this.redis.zadd(key, Date.now(), JSON.stringify(data));
    await this.redis.expire(key, 86400 * 30); // 30 days retention
  }

  async getActiveUsers(windowMinutes: number = 60): Promise<number> {
    const cutoff = Date.now() - (windowMinutes * 60 * 1000);
    const sessions = await this.redis.keys('session:user:*');

    let activeCount = 0;
    for (const key of sessions) {
      const session = await this.redis.get(key);
      if (session) {
        const data = JSON.parse(session) as UserSession;
        if (new Date(data.context.lastActivity).getTime() > cutoff) {
          activeCount++;
        }
      }
    }

    return activeCount;
  }

  async getUserStats(userId: string): Promise<{
    totalCommands: number;
    successRate: number;
    mostUsedCommands: string[];
    lastActive: Date;
  }> {
    const key = `analytics:commands:${userId}`;
    const commands = await this.redis.zrange(key, 0, -1);

    const commandCounts: Record<string, number> = {};
    let successCount = 0;

    for (const cmdStr of commands) {
      const cmd = JSON.parse(cmdStr);
      commandCounts[cmd.command] = (commandCounts[cmd.command] || 0) + 1;
      if (cmd.success) successCount++;
    }

    const sortedCommands = Object.entries(commandCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([cmd]) => cmd);

    const sessionKey = `session:user:${userId}`;
    const sessionData = await this.redis.get(sessionKey);
    const session = sessionData ? JSON.parse(sessionData) as UserSession : null;

    return {
      totalCommands: commands.length,
      successRate: commands.length > 0 ? successCount / commands.length : 0,
      mostUsedCommands: sortedCommands,
      lastActive: session?.context.lastActivity || new Date(0),
    };
  }
}
```

## Implementation Checklist

### Phase 1: Core Session Management
- [ ] Implement Redis session storage
- [ ] Create session middleware
- [ ] Add session initialization logic
- [ ] Implement session TTL management

### Phase 2: User Preferences
- [ ] Build preference UI commands
- [ ] Implement timezone management
- [ ] Add notification preferences
- [ ] Create working hours configuration

### Phase 3: Workflow Management
- [ ] Create workflow manager
- [ ] Implement multi-step conversations
- [ ] Add workflow timeout handling
- [ ] Build workflow cancellation

### Phase 4: Analytics & Monitoring
- [ ] Implement command tracking
- [ ] Add session analytics
- [ ] Create usage dashboards
- [ ] Set up inactive user alerts

## Testing Requirements

```typescript
describe('Session Management', () => {
  let storage: RedisSessionStorage;
  let redis: Redis;

  beforeEach(() => {
    redis = new Redis({ db: 1 }); // Test DB
    storage = new RedisSessionStorage(redis);
  });

  afterEach(async () => {
    await redis.flushdb();
    redis.disconnect();
  });

  it('should create and retrieve session', async () => {
    const session = createNewSession(mockContext);
    await storage.write('user:123', session);

    const retrieved = await storage.read('user:123');
    expect(retrieved?.userId).toBe(session.userId);
  });

  it('should expire sessions after TTL', async () => {
    const session = createNewSession(mockContext);
    await storage.write('user:123', session);

    // Fast-forward time
    await redis.expire('session:user:123', 1);
    await sleep(1100);

    const retrieved = await storage.read('user:123');
    expect(retrieved).toBeUndefined();
  });

  it('should handle concurrent workflow updates', async () => {
    const manager = new WorkflowManager();
    manager.register(createTaskWorkflow);

    const session1 = createNewSession(mockContext);
    const session2 = createNewSession(mockContext);

    await Promise.all([
      manager.start(mockContext, session1, 'create-task'),
      manager.start(mockContext, session2, 'create-task'),
    ]);

    expect(session1.context.currentWorkflow).toBe('create-task');
    expect(session2.context.currentWorkflow).toBe('create-task');
  });
});
```

## Performance Specifications
- Session read latency: < 10ms
- Session write latency: < 20ms
- Maximum concurrent sessions: 10,000
- Session data size limit: 64KB
- Workflow timeout: 5 minutes default
- Analytics retention: 30 days

## Security Requirements
- Encrypt sensitive session data at rest
- Use separate Redis databases per environment
- Implement session hijacking prevention
- Rate limit preference updates
- Audit trail for critical preference changes
- GDPR compliance for data retention

## Developer Resources

### Essential Documentation
```bash
# grammY sessions
mcp__ref__ref_search_documentation "grammY TypeScript session management Redis"

# Redis session patterns
mcp__ref__ref_search_documentation "Redis session storage TTL TypeScript"

# Conversation flows
mcp__ref__ref_search_documentation "grammY conversations multi-step workflows"
```

## Acceptance Criteria
1. ‚úÖ Sessions persist across bot restarts
2. ‚úÖ User preferences are applied to all commands
3. ‚úÖ Multi-step workflows maintain state correctly
4. ‚úÖ Session analytics track user activity
5. ‚úÖ Inactive sessions are cleaned up automatically
6. ‚úÖ Concurrent users don't interfere with each other

## Notes for Developers
- Always check session existence before accessing
- Use atomic Redis operations for concurrent safety
- Implement graceful degradation if Redis is unavailable
- Keep session data minimal to reduce memory usage
- Test workflow interruptions and edge cases
- Consider implementing session migration for schema changes