# Story 4.5: List Notifications

## Overview
Implement a comprehensive notification system for list-related events including reminders, due dates, sharing updates, completion tracking, and collaborative changes, delivered through multiple channels with smart batching and user preferences.

## Context
- **Epic**: Epic 4 - Lists Management
- **Priority**: P2 (Critical for user engagement and task completion)
- **Dependencies**:
  - Story 4.1 (Lists Interface) - COMPLETED
  - Story 4.2 (List Management Commands) - COMPLETED
  - Story 4.4 (List Sharing & Permissions) - Required for collaboration notifications
  - Story 2.2 (Telegram Reminder System) - Provides notification infrastructure
- **Blocks**: None - final story in lists epic

## Technical Requirements

### Core Notification Architecture
```typescript
// Notification system models
interface ListNotification {
  id: string;
  type: NotificationType;
  recipientId: string;
  listId: string;
  itemId?: string;
  priority: NotificationPriority;
  channels: NotificationChannel[];
  payload: NotificationPayload;
  scheduledFor?: Date;
  sentAt?: Date;
  readAt?: Date;
  actionTaken?: string;
  metadata: NotificationMetadata;
}

enum NotificationType {
  // Time-based
  ITEM_DUE_SOON = 'item_due_soon',
  ITEM_OVERDUE = 'item_overdue',
  LIST_REMINDER = 'list_reminder',
  RECURRING_TASK = 'recurring_task',

  // Collaboration
  LIST_SHARED = 'list_shared',
  PERMISSION_CHANGED = 'permission_changed',
  ITEM_ASSIGNED = 'item_assigned',
  ITEM_COMPLETED_BY_OTHER = 'item_completed_by_other',
  COMMENT_ADDED = 'comment_added',
  MENTION = 'mention',

  // Progress tracking
  LIST_COMPLETED = 'list_completed',
  MILESTONE_REACHED = 'milestone_reached',
  DAILY_SUMMARY = 'daily_summary',
  WEEKLY_REPORT = 'weekly_report',

  // System
  TEMPLATE_UPDATE = 'template_update',
  LIST_ARCHIVED = 'list_archived',
  BULK_CHANGES = 'bulk_changes'
}

enum NotificationPriority {
  URGENT = 'urgent',      // Immediate delivery
  HIGH = 'high',          // Within 5 minutes
  NORMAL = 'normal',      // Within 30 minutes
  LOW = 'low',            // Batched delivery
  DIGEST = 'digest'       // Daily/weekly digest
}

interface NotificationChannel {
  type: 'telegram' | 'email' | 'sms' | 'push' | 'in_app';
  enabled: boolean;
  config: ChannelConfig;
  fallback?: NotificationChannel;
}

interface NotificationPayload {
  title: string;
  body: string;
  data: Record<string, any>;
  actions?: NotificationAction[];
  deepLink?: string;
  expiresAt?: Date;
}

interface NotificationPreferences {
  userId: string;
  channels: ChannelPreference[];
  quietHours?: QuietHours;
  batching: BatchingPreferences;
  filters: NotificationFilter[];
  language: string;
  timezone: string;
}
```

### PostgreSQL Notification Schema
```sql
-- Notification queue and history
CREATE TABLE list_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type VARCHAR(50) NOT NULL,
  recipient_id UUID NOT NULL REFERENCES personnel(id),
  list_id UUID REFERENCES user_lists(id),
  item_id UUID,
  priority VARCHAR(20) NOT NULL DEFAULT 'normal',
  channels JSONB NOT NULL DEFAULT '[]',
  payload JSONB NOT NULL,
  scheduled_for TIMESTAMPTZ,
  sent_at TIMESTAMPTZ,
  delivered_at TIMESTAMPTZ,
  read_at TIMESTAMPTZ,
  clicked_at TIMESTAMPTZ,
  action_taken VARCHAR(50),
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT valid_priority CHECK (priority IN ('urgent', 'high', 'normal', 'low', 'digest'))
);

-- User notification preferences
CREATE TABLE notification_preferences (
  user_id UUID PRIMARY KEY REFERENCES personnel(id),
  telegram_enabled BOOLEAN DEFAULT true,
  email_enabled BOOLEAN DEFAULT false,
  sms_enabled BOOLEAN DEFAULT false,
  push_enabled BOOLEAN DEFAULT true,
  quiet_hours_start TIME,
  quiet_hours_end TIME,
  quiet_hours_timezone VARCHAR(50) DEFAULT 'UTC',
  batch_low_priority BOOLEAN DEFAULT true,
  batch_window_minutes INTEGER DEFAULT 30,
  daily_digest_time TIME DEFAULT '09:00',
  weekly_digest_day INTEGER DEFAULT 1, -- Monday
  language VARCHAR(10) DEFAULT 'en',
  timezone VARCHAR(50) DEFAULT 'UTC',
  filters JSONB DEFAULT '[]',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Notification templates for consistent messaging
CREATE TABLE notification_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type VARCHAR(50) NOT NULL UNIQUE,
  channel VARCHAR(20) NOT NULL,
  language VARCHAR(10) DEFAULT 'en',
  subject_template TEXT,
  body_template TEXT NOT NULL,
  action_templates JSONB,
  variables JSONB,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Notification subscriptions for custom alerts
CREATE TABLE notification_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES personnel(id),
  subscription_type VARCHAR(50) NOT NULL,
  target_type VARCHAR(20), -- 'list', 'user', 'team', etc.
  target_id VARCHAR(255),
  conditions JSONB,
  channels JSONB DEFAULT '["telegram"]',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  CONSTRAINT unique_subscription UNIQUE(user_id, subscription_type, target_id)
);

-- Smart notification batching
CREATE TABLE notification_batches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES personnel(id),
  batch_type VARCHAR(20) NOT NULL,
  notifications UUID[] NOT NULL,
  scheduled_for TIMESTAMPTZ NOT NULL,
  sent_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Analytics for notification effectiveness
CREATE TABLE notification_analytics (
  notification_id UUID PRIMARY KEY REFERENCES list_notifications(id),
  delivered_at TIMESTAMPTZ,
  opened_at TIMESTAMPTZ,
  clicked_at TIMESTAMPTZ,
  action_taken VARCHAR(50),
  action_taken_at TIMESTAMPTZ,
  device_type VARCHAR(50),
  client_info JSONB,
  effectiveness_score DECIMAL(3,2)
);

-- Indexes for performance
CREATE INDEX idx_notifications_recipient ON list_notifications(recipient_id, scheduled_for)
  WHERE sent_at IS NULL;
CREATE INDEX idx_notifications_scheduled ON list_notifications(scheduled_for)
  WHERE sent_at IS NULL AND scheduled_for IS NOT NULL;
CREATE INDEX idx_notifications_list ON list_notifications(list_id, type);
CREATE INDEX idx_notification_analytics ON notification_analytics(notification_id, opened_at);
```

### Notification Service Implementation
```typescript
import { EventEmitter } from 'events';
import { CronJob } from 'cron';
import { Temporal } from '@js-temporal/polyfill';

class NotificationService extends EventEmitter {
  private notificationQueue: PriorityQueue<ListNotification>;
  private batchProcessor: BatchProcessor;
  private channelHandlers: Map<string, ChannelHandler>;

  constructor(
    private supabase: SupabaseClient,
    private telegramBot: TelegramBot,
    private emailService: EmailService
  ) {
    super();
    this.initializeChannelHandlers();
    this.startNotificationProcessor();
  }

  /**
   * Smart notification scheduling with batching
   */
  async scheduleNotification(
    notification: CreateNotificationDto
  ): Promise<ListNotification> {
    // Check user preferences
    const preferences = await this.getUserPreferences(notification.recipientId);

    // Apply quiet hours
    const scheduledTime = this.applyQuietHours(
      notification.scheduledFor || new Date(),
      preferences
    );

    // Determine if should batch
    const shouldBatch = this.shouldBatchNotification(
      notification,
      preferences
    );

    if (shouldBatch) {
      return this.addToBatch(notification, preferences);
    }

    // Create notification record
    const { data: notif } = await this.supabase
      .from('list_notifications')
      .insert({
        type: notification.type,
        recipient_id: notification.recipientId,
        list_id: notification.listId,
        item_id: notification.itemId,
        priority: notification.priority || 'normal',
        channels: this.selectChannels(notification, preferences),
        payload: this.buildPayload(notification),
        scheduled_for: scheduledTime,
        metadata: notification.metadata
      })
      .select()
      .single();

    // Add to processing queue
    if (notification.priority === 'urgent') {
      await this.processImmediately(notif);
    } else {
      this.notificationQueue.enqueue(notif, this.getPriorityScore(notif));
    }

    return notif;
  }

  /**
   * Intelligent notification batching
   */
  private async addToBatch(
    notification: CreateNotificationDto,
    preferences: NotificationPreferences
  ): Promise<ListNotification> {
    const batchWindow = preferences.batching.windowMinutes || 30;
    const batchTime = this.calculateBatchTime(new Date(), batchWindow);

    // Find or create batch
    let batch = await this.findActiveBatch(
      notification.recipientId,
      notification.priority,
      batchTime
    );

    if (!batch) {
      batch = await this.createBatch(
        notification.recipientId,
        notification.priority,
        batchTime
      );
    }

    // Add notification to batch
    const notif = await this.createNotification(notification);
    await this.addNotificationToBatch(notif.id, batch.id);

    return notif;
  }

  /**
   * Multi-channel delivery with fallback
   */
  async deliverNotification(notification: ListNotification): Promise<DeliveryResult> {
    const results: ChannelResult[] = [];

    for (const channel of notification.channels) {
      try {
        const handler = this.channelHandlers.get(channel.type);
        if (!handler) continue;

        const result = await handler.send(notification, channel.config);
        results.push(result);

        if (result.success) {
          await this.markDelivered(notification.id, channel.type);
          break; // Stop if successfully delivered
        }
      } catch (error) {
        console.error(`Failed to deliver via ${channel.type}:`, error);

        // Try fallback channel if configured
        if (channel.fallback) {
          notification.channels = [channel.fallback];
          return this.deliverNotification(notification);
        }
      }
    }

    return {
      success: results.some(r => r.success),
      channels: results,
      notification: notification
    };
  }

  /**
   * Telegram notification handler with rich formatting
   */
  private initializeTelegramHandler(): ChannelHandler {
    return {
      send: async (notification: ListNotification, config: any) => {
        const message = this.formatTelegramMessage(notification);
        const keyboard = this.buildTelegramKeyboard(notification);

        try {
          const result = await this.telegramBot.sendMessage(
            config.chatId || notification.recipientId,
            message,
            {
              parse_mode: 'Markdown',
              reply_markup: keyboard,
              disable_notification: notification.priority === 'low'
            }
          );

          return {
            success: true,
            messageId: result.message_id,
            channel: 'telegram'
          };
        } catch (error) {
          throw new DeliveryError('Telegram delivery failed', error);
        }
      }
    };
  }

  /**
   * Format notification for Telegram
   */
  private formatTelegramMessage(notification: ListNotification): string {
    const emoji = this.getNotificationEmoji(notification.type);
    const { title, body, data } = notification.payload;

    let message = `${emoji} *${title}*\n\n${body}`;

    // Add contextual information
    if (data.listName) {
      message += `\n\nüìã List: ${data.listName}`;
    }

    if (data.dueDate) {
      const due = Temporal.Instant.from(data.dueDate);
      const now = Temporal.Now.instant();
      const duration = now.until(due);

      if (duration.total('hours') < 24) {
        message += `\n‚è∞ Due: ${this.formatRelativeTime(duration)}`;
      } else {
        message += `\nüìÖ Due: ${this.formatDate(due)}`;
      }
    }

    if (data.completionPercentage) {
      const progress = this.generateProgressBar(data.completionPercentage);
      message += `\n\n${progress} ${data.completionPercentage}% complete`;
    }

    return message;
  }

  /**
   * Build interactive Telegram keyboard
   */
  private buildTelegramKeyboard(notification: ListNotification): any {
    const actions = notification.payload.actions || [];

    if (actions.length === 0) return null;

    const keyboard = {
      inline_keyboard: []
    };

    // Group actions by row (max 2 per row for mobile)
    for (let i = 0; i < actions.length; i += 2) {
      const row = actions.slice(i, i + 2).map(action => ({
        text: action.label,
        callback_data: `notif_action:${notification.id}:${action.id}`
      }));
      keyboard.inline_keyboard.push(row);
    }

    // Add dismiss option
    keyboard.inline_keyboard.push([
      { text: '‚úÖ Mark as Read', callback_data: `notif_read:${notification.id}` },
      { text: 'üîï Mute Similar', callback_data: `notif_mute:${notification.type}` }
    ]);

    return keyboard;
  }

  /**
   * Smart digest generation
   */
  async generateDigest(
    userId: string,
    digestType: 'daily' | 'weekly'
  ): Promise<DigestNotification> {
    const period = digestType === 'daily' ? '1 day' : '7 days';

    // Get user's activity summary
    const { data: summary } = await this.supabase.rpc('get_user_activity_summary', {
      user_id: userId,
      period: period
    });

    // Get pending items
    const { data: pendingItems } = await this.supabase
      .from('list_items')
      .select(`
        *,
        list:user_lists(name)
      `)
      .eq('assigned_to', userId)
      .eq('completed', false)
      .order('due_date', { ascending: true })
      .limit(10);

    // Get completed items
    const { data: completedItems } = await this.supabase
      .from('list_items')
      .select('*')
      .eq('assigned_to', userId)
      .eq('completed', true)
      .gte('completed_at', `now() - interval '${period}'`)
      .order('completed_at', { ascending: false });

    // Generate insights
    const insights = this.generateInsights(summary, pendingItems, completedItems);

    // Build digest
    return {
      userId,
      type: digestType,
      period: {
        start: new Date(Date.now() - this.getPeriodMs(period)),
        end: new Date()
      },
      summary: {
        tasksCompleted: completedItems.length,
        tasksPending: pendingItems.length,
        listsActive: summary.active_lists,
        collaborators: summary.collaborators
      },
      highlights: this.extractHighlights(completedItems),
      upcoming: this.formatUpcoming(pendingItems),
      insights,
      generatedAt: new Date()
    };
  }

  /**
   * AI-powered notification insights
   */
  private generateInsights(
    summary: any,
    pending: any[],
    completed: any[]
  ): NotificationInsight[] {
    const insights: NotificationInsight[] = [];

    // Productivity trend
    const completionRate = completed.length / (completed.length + pending.length);
    if (completionRate > 0.8) {
      insights.push({
        type: 'achievement',
        message: 'Great job! You completed 80% of your tasks',
        emoji: 'üåü'
      });
    }

    // Overdue alert
    const overdue = pending.filter(item =>
      item.due_date && new Date(item.due_date) < new Date()
    );
    if (overdue.length > 0) {
      insights.push({
        type: 'alert',
        message: `${overdue.length} tasks are overdue`,
        emoji: '‚ö†Ô∏è',
        action: 'Review overdue tasks'
      });
    }

    // Collaboration highlight
    if (summary.collaborators > 5) {
      insights.push({
        type: 'collaboration',
        message: `You collaborated with ${summary.collaborators} people this week`,
        emoji: 'ü§ù'
      });
    }

    // Pattern detection
    const patterns = this.detectPatterns(completed);
    if (patterns.mostProductiveTime) {
      insights.push({
        type: 'pattern',
        message: `You're most productive ${patterns.mostProductiveTime}`,
        emoji: 'üìä'
      });
    }

    return insights;
  }

  /**
   * Quiet hours enforcement
   */
  private applyQuietHours(
    scheduledTime: Date,
    preferences: NotificationPreferences
  ): Date {
    if (!preferences.quietHours) return scheduledTime;

    const { start, end, timezone } = preferences.quietHours;
    const userTime = Temporal.ZonedDateTime.from({
      timeZone: timezone,
      year: scheduledTime.getFullYear(),
      month: scheduledTime.getMonth() + 1,
      day: scheduledTime.getDate(),
      hour: scheduledTime.getHours(),
      minute: scheduledTime.getMinutes()
    });

    const quietStart = userTime.with({
      hour: parseInt(start.split(':')[0]),
      minute: parseInt(start.split(':')[1])
    });

    const quietEnd = userTime.with({
      hour: parseInt(end.split(':')[0]),
      minute: parseInt(end.split(':')[1])
    });

    // Check if in quiet hours
    if (userTime >= quietStart && userTime <= quietEnd) {
      // Defer to end of quiet hours
      return new Date(quietEnd.epochMilliseconds);
    }

    return scheduledTime;
  }

  /**
   * Notification effectiveness tracking
   */
  async trackEffectiveness(
    notificationId: string,
    event: EffectivenessEvent
  ): Promise<void> {
    const updates: any = {
      notification_id: notificationId,
      [event.type + '_at']: new Date()
    };

    if (event.action) {
      updates.action_taken = event.action;
      updates.action_taken_at = new Date();
    }

    // Calculate effectiveness score
    const score = this.calculateEffectivenessScore(event);
    updates.effectiveness_score = score;

    await this.supabase
      .from('notification_analytics')
      .upsert(updates);

    // Update ML model with feedback
    await this.updateNotificationModel(notificationId, score);
  }

  private calculateEffectivenessScore(event: EffectivenessEvent): number {
    let score = 0;

    // Base scores for different events
    const scores = {
      delivered: 0.2,
      opened: 0.3,
      clicked: 0.4,
      action_taken: 0.5
    };

    // Time-based multiplier (faster response = higher score)
    const responseTime = event.timestamp.getTime() - event.sentAt.getTime();
    const timeMultiplier = Math.max(0.5, 1 - (responseTime / (24 * 60 * 60 * 1000)));

    score = (scores[event.type] || 0) * timeMultiplier;

    return Math.min(1, score);
  }
}
```

### Telegram Notification Commands
```typescript
class TelegramNotificationHandler {
  /**
   * Handle notification preferences command
   */
  async handlePreferencesCommand(ctx: Context): Promise<void> {
    const keyboard = new InlineKeyboard()
      .row(
        InlineKeyboard.text('üîî Channels', 'pref_channels'),
        InlineKeyboard.text('üåô Quiet Hours', 'pref_quiet')
      )
      .row(
        InlineKeyboard.text('üì¶ Batching', 'pref_batch'),
        InlineKeyboard.text('üéØ Filters', 'pref_filters')
      )
      .row(
        InlineKeyboard.text('üìä Digest Settings', 'pref_digest'),
        InlineKeyboard.text('üåç Language', 'pref_language')
      );

    await ctx.reply(
      '‚öôÔ∏è *Notification Preferences*\n\n' +
      'Customize how and when you receive notifications:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Configure quiet hours
   */
  async configureQuietHours(ctx: Context): Promise<void> {
    const currentSettings = await this.getQuietHours(ctx.from.id);

    const keyboard = new InlineKeyboard();

    // Pre-defined quiet hour options
    const options = [
      { label: 'üåÉ Night (10 PM - 7 AM)', start: '22:00', end: '07:00' },
      { label: 'üåô Late Night (11 PM - 6 AM)', start: '23:00', end: '06:00' },
      { label: 'üíº Work Hours Only (9 AM - 5 PM)', start: '17:00', end: '09:00' },
      { label: 'üéØ Custom Hours', custom: true }
    ];

    options.forEach(opt => {
      if (opt.custom) {
        keyboard.row(
          InlineKeyboard.text(opt.label, 'quiet_custom')
        );
      } else {
        keyboard.row(
          InlineKeyboard.text(
            opt.label,
            `quiet_set:${opt.start}:${opt.end}`
          )
        );
      }
    });

    keyboard.row(
      InlineKeyboard.text('‚ùå Disable Quiet Hours', 'quiet_disable'),
      InlineKeyboard.text('‚Üê Back', 'pref_back')
    );

    const status = currentSettings.enabled
      ? `Currently: ${currentSettings.start} - ${currentSettings.end}`
      : 'Currently: Disabled';

    await ctx.editMessageText(
      'üåô *Quiet Hours Settings*\n\n' +
      `${status}\n\n` +
      'During quiet hours, non-urgent notifications will be held until the quiet period ends.\n\n' +
      'Select your preferred quiet hours:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Show notification history
   */
  async showNotificationHistory(ctx: Context): Promise<void> {
    const userId = ctx.from.id;
    const notifications = await this.notificationService.getUserNotifications(
      userId,
      { limit: 10, includeRead: true }
    );

    if (notifications.length === 0) {
      await ctx.reply('No notifications yet.');
      return;
    }

    const keyboard = new InlineKeyboard();
    const grouped = this.groupNotificationsByDate(notifications);

    let message = 'üì¨ *Notification History*\n\n';

    Object.entries(grouped).forEach(([date, notifs]) => {
      message += `*${date}*\n`;

      notifs.forEach(notif => {
        const icon = notif.read_at ? 'üìñ' : 'üì©';
        const time = this.formatTime(notif.created_at);
        message += `${icon} ${time} - ${notif.payload.title}\n`;

        // Add action button for unread
        if (!notif.read_at) {
          keyboard.row(
            InlineKeyboard.text(
              `View: ${notif.payload.title.substring(0, 20)}...`,
              `notif_view:${notif.id}`
            )
          );
        }
      });
      message += '\n';
    });

    keyboard.row(
      InlineKeyboard.text('üóë Clear All', 'notif_clear_all'),
      InlineKeyboard.text('‚öôÔ∏è Settings', 'notif_settings')
    );

    await ctx.reply(message, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  /**
   * Subscribe to custom notifications
   */
  async createCustomSubscription(ctx: Context): Promise<void> {
    await ctx.reply(
      'üîî *Create Custom Alert*\n\n' +
      'I can notify you when specific conditions are met.\n\n' +
      'What would you like to be notified about?\n\n' +
      'Examples:\n' +
      '‚Ä¢ "When any task is overdue"\n' +
      '‚Ä¢ "When someone completes an item I assigned"\n' +
      '‚Ä¢ "Daily summary at 9 AM"\n' +
      '‚Ä¢ "When a high-priority task is added"',
      { parse_mode: 'Markdown' }
    );

    // Store conversation state for multi-step subscription
    await this.stateManager.setState(ctx.from.id, {
      action: 'creating_subscription',
      step: 'condition'
    });
  }
}
```

### Notification Triggers and Rules
```typescript
// Event-driven notification triggers
class NotificationTriggerEngine {
  private rules: NotificationRule[] = [];

  /**
   * Register notification rules
   */
  registerDefaultRules(): void {
    // Due date reminders
    this.addRule({
      name: 'due_soon_reminder',
      trigger: 'time_based',
      condition: (item) => {
        const hoursUntilDue = this.getHoursUntilDue(item.due_date);
        return hoursUntilDue > 0 && hoursUntilDue <= 24;
      },
      action: async (item) => {
        await this.notificationService.scheduleNotification({
          type: NotificationType.ITEM_DUE_SOON,
          recipientId: item.assigned_to,
          listId: item.list_id,
          itemId: item.id,
          priority: 'high',
          payload: {
            title: 'Task Due Soon',
            body: `"${item.text}" is due in ${this.getHoursUntilDue(item.due_date)} hours`,
            actions: [
              { id: 'complete', label: '‚úÖ Mark Complete' },
              { id: 'snooze', label: '‚è∞ Snooze 1 Hour' }
            ]
          }
        });
      }
    });

    // Overdue notifications
    this.addRule({
      name: 'overdue_escalation',
      trigger: 'time_based',
      condition: (item) => {
        return item.due_date && new Date(item.due_date) < new Date() && !item.completed;
      },
      action: async (item) => {
        const hoursOverdue = this.getHoursOverdue(item.due_date);
        const priority = hoursOverdue > 24 ? 'urgent' : 'high';

        await this.notificationService.scheduleNotification({
          type: NotificationType.ITEM_OVERDUE,
          recipientId: item.assigned_to,
          listId: item.list_id,
          itemId: item.id,
          priority,
          payload: {
            title: '‚ö†Ô∏è Task Overdue',
            body: `"${item.text}" is ${this.formatOverdue(hoursOverdue)} overdue`,
            actions: [
              { id: 'complete', label: '‚úÖ Complete Now' },
              { id: 'reschedule', label: 'üìÖ Reschedule' },
              { id: 'delegate', label: 'üë• Delegate' }
            ]
          }
        });
      }
    });

    // Collaboration notifications
    this.addRule({
      name: 'item_completed_notification',
      trigger: 'event',
      event: 'item.completed',
      condition: (event) => {
        return event.completedBy !== event.item.assigned_to;
      },
      action: async (event) => {
        await this.notificationService.scheduleNotification({
          type: NotificationType.ITEM_COMPLETED_BY_OTHER,
          recipientId: event.item.assigned_to,
          listId: event.item.list_id,
          itemId: event.item.id,
          priority: 'normal',
          payload: {
            title: 'Task Completed',
            body: `${event.completedByName} completed "${event.item.text}"`,
            actions: [
              { id: 'view', label: 'üëÄ View Details' },
              { id: 'thank', label: 'üëç Say Thanks' }
            ]
          }
        });
      }
    });

    // Milestone notifications
    this.addRule({
      name: 'milestone_reached',
      trigger: 'event',
      event: 'list.milestone',
      condition: (event) => {
        const milestones = [25, 50, 75, 100];
        return milestones.includes(event.completionPercentage);
      },
      action: async (event) => {
        await this.notificationService.scheduleNotification({
          type: NotificationType.MILESTONE_REACHED,
          recipientId: event.userId,
          listId: event.listId,
          priority: 'normal',
          payload: {
            title: `üéØ ${event.completionPercentage}% Complete!`,
            body: `Great progress on "${event.listName}"`,
            actions: [
              { id: 'view', label: 'üìã View List' },
              { id: 'share', label: 'üéâ Share Progress' }
            ]
          }
        });
      }
    });
  }

  /**
   * Process events and trigger notifications
   */
  async processEvent(event: SystemEvent): Promise<void> {
    const applicableRules = this.rules.filter(rule =>
      rule.trigger === 'event' && rule.event === event.type
    );

    for (const rule of applicableRules) {
      if (await rule.condition(event)) {
        await rule.action(event);
      }
    }
  }
}
```

### n8n Notification Workflow
```json
{
  "name": "Notification Processing Workflow",
  "nodes": [
    {
      "type": "n8n-nodes-base.cron",
      "name": "Notification Scheduler",
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        }
      }
    },
    {
      "type": "n8n-nodes-base.postgres",
      "name": "Get Pending Notifications",
      "parameters": {
        "operation": "executeQuery",
        "query": `
          SELECT
            n.*,
            u.telegram_chat_id,
            u.email,
            u.phone,
            p.quiet_hours_start,
            p.quiet_hours_end,
            p.timezone
          FROM list_notifications n
          JOIN personnel u ON n.recipient_id = u.id
          LEFT JOIN notification_preferences p ON u.id = p.user_id
          WHERE n.sent_at IS NULL
            AND (n.scheduled_for IS NULL OR n.scheduled_for <= NOW())
            AND n.retry_count < 3
          ORDER BY
            CASE n.priority
              WHEN 'urgent' THEN 1
              WHEN 'high' THEN 2
              WHEN 'normal' THEN 3
              WHEN 'low' THEN 4
            END,
            n.created_at
          LIMIT 50
        `
      }
    },
    {
      "type": "n8n-nodes-base.function",
      "name": "Apply Quiet Hours",
      "parameters": {
        "functionCode": `
          const notifications = $input.all();
          const processNow = [];
          const deferredNotifications = [];

          for (const notif of notifications) {
            const item = notif.json;

            // Check if in quiet hours
            if (item.quiet_hours_start && item.priority !== 'urgent') {
              const now = new Date();
              const userTime = convertToUserTimezone(now, item.timezone);

              if (isInQuietHours(userTime, item.quiet_hours_start, item.quiet_hours_end)) {
                deferredNotifications.push(item);
                continue;
              }
            }

            processNow.push(item);
          }

          // Update deferred notifications
          if (deferredNotifications.length > 0) {
            await updateScheduledTime(deferredNotifications);
          }

          return processNow.map(item => ({ json: item }));
        `
      }
    },
    {
      "type": "n8n-nodes-base.switch",
      "name": "Route by Channel",
      "parameters": {
        "dataType": "string",
        "value1": "={{$json.channels[0].type}}",
        "rules": {
          "rules": [
            {
              "value1": "={{$json.channels[0].type}}",
              "value2": "telegram"
            },
            {
              "value1": "={{$json.channels[0].type}}",
              "value2": "email"
            },
            {
              "value1": "={{$json.channels[0].type}}",
              "value2": "sms"
            }
          ]
        }
      }
    },
    {
      "type": "n8n-nodes-base.telegram",
      "name": "Send Telegram",
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{$json.telegram_chat_id}}",
        "text": "={{$json.payload.body}}",
        "additionalFields": {
          "parse_mode": "Markdown",
          "reply_markup": "={{JSON.stringify($json.keyboard)}}"
        }
      }
    }
  ]
}
```

## Implementation Checklist

### Phase 1: Database Setup
- [ ] Create notification tables
- [ ] Set up preference management
- [ ] Implement notification templates
- [ ] Add analytics tracking

### Phase 2: Core Notification Logic
- [ ] Build NotificationService class
- [ ] Implement channel handlers
- [ ] Add batching system
- [ ] Create digest generator

### Phase 3: Telegram Integration
- [ ] Add preference commands
- [ ] Build notification UI
- [ ] Implement action handlers
- [ ] Add subscription management

### Phase 4: Advanced Features
- [ ] Implement quiet hours
- [ ] Add smart batching
- [ ] Build analytics dashboard
- [ ] Create ML-based optimization

## Testing Requirements

```typescript
describe('Notification System', () => {
  describe('Delivery', () => {
    it('should respect quiet hours', async () => {
      const notification = createTestNotification({
        priority: 'normal',
        scheduledFor: new Date('2025-01-13T23:00:00') // 11 PM
      });

      const preferences = {
        quietHours: {
          start: '22:00',
          end: '07:00',
          timezone: 'America/New_York'
        }
      };

      const scheduled = await notificationService.scheduleNotification(
        notification,
        preferences
      );

      // Should be deferred to 7 AM
      expect(scheduled.scheduled_for.getHours()).toBe(7);
    });

    it('should batch low-priority notifications', async () => {
      const notifications = Array(5).fill(null).map(() =>
        createTestNotification({ priority: 'low' })
      );

      const scheduled = await Promise.all(
        notifications.map(n => notificationService.scheduleNotification(n))
      );

      // All should be in same batch
      const batches = await notificationService.getBatches();
      expect(batches.length).toBe(1);
      expect(batches[0].notifications.length).toBe(5);
    });

    it('should fallback to alternative channels', async () => {
      const notification = createTestNotification({
        channels: [
          { type: 'telegram', config: {} },
          { type: 'email', config: {}, fallback: true }
        ]
      });

      // Mock Telegram failure
      telegramBot.sendMessage.mockRejectedValue(new Error('Failed'));

      const result = await notificationService.deliverNotification(notification);

      expect(result.success).toBe(true);
      expect(result.channels[1].channel).toBe('email');
    });
  });
});
```

## Performance Specifications
- Notification scheduling: < 50ms per notification
- Batch processing: 1000+ notifications per minute
- Digest generation: < 500ms for weekly digest
- Channel delivery: < 2 seconds per notification
- Preference updates: < 100ms

## Security Requirements
- Encrypt notification content in database
- Validate all recipient permissions
- Rate limit notification creation (100/user/hour)
- Sanitize all user-generated content
- Audit notification access and delivery
- Implement unsubscribe mechanisms

## Developer Resources

### Essential Documentation
```bash
# Notification system patterns
mcp__ref__ref_search_documentation "notification system architecture push pull patterns"

# Telegram bot notifications
mcp__ref__ref_search_documentation "Telegram bot notification batching quiet hours"

# PostgreSQL job queues
mcp__ref__ref_search_documentation "PostgreSQL notification queue implementation"
```

### Debugging Commands
```sql
-- Check notification delivery status
SELECT
  type,
  priority,
  COUNT(*) as count,
  AVG(EXTRACT(EPOCH FROM (sent_at - created_at))) as avg_delay_seconds
FROM list_notifications
WHERE created_at > NOW() - INTERVAL '24 hours'
GROUP BY type, priority
ORDER BY priority;

-- User notification preferences
SELECT
  u.name,
  np.*,
  COUNT(n.id) as notifications_sent
FROM notification_preferences np
JOIN personnel u ON np.user_id = u.id
LEFT JOIN list_notifications n ON n.recipient_id = u.id
GROUP BY u.name, np.user_id;

-- Notification effectiveness
SELECT
  type,
  COUNT(*) as sent,
  COUNT(read_at) as read,
  COUNT(action_taken) as acted,
  AVG(effectiveness_score) as avg_effectiveness
FROM list_notifications n
LEFT JOIN notification_analytics na ON n.id = na.notification_id
WHERE n.sent_at > NOW() - INTERVAL '7 days'
GROUP BY type
ORDER BY avg_effectiveness DESC;
```

## Acceptance Criteria
1. ‚úÖ Notifications delivered based on user preferences
2. ‚úÖ Quiet hours respected for non-urgent notifications
3. ‚úÖ Smart batching reduces notification fatigue
4. ‚úÖ Multi-channel delivery with fallback
5. ‚úÖ Analytics track notification effectiveness
6. ‚úÖ Digest summaries provide valuable insights

## Notes for Developers
- Cache user preferences for performance
- Use database triggers for event notifications
- Implement exponential backoff for retries
- Consider push notification service integration
- Plan for notification template versioning
- Monitor delivery rates and adjust accordingly