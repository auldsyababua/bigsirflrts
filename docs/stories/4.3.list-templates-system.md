# Story 4.3: List Templates System

## Overview
Implement a comprehensive template system for frequently-used lists, enabling users to quickly create standardized checklists for recurring tasks like site inspections, maintenance procedures, and safety protocols.

## Context
- **Epic**: Epic 4 - Lists Management
- **Priority**: P2 (Nice-to-have for MVP, critical for efficiency)
- **Dependencies**:
  - Story 4.1 (Lists Interface) - COMPLETED
  - Story 4.2 (List Management Commands) - COMPLETED
  - Story 1.4 (Supabase Edge Functions) - Required for template storage
- **Blocks**: None directly, enhances all list-related features

## Technical Requirements

### Core Template Architecture
```typescript
// Template data structures
interface ListTemplate {
  id: string;
  name: string;
  category: TemplateCategory;
  description: string;
  icon: string;
  items: TemplateItem[];
  metadata: TemplateMetadata;
  visibility: 'personal' | 'team' | 'organization' | 'public';
  createdBy: string;
  createdAt: Date;
  updatedAt: Date;
  usageCount: number;
  tags: string[];
}

interface TemplateItem {
  id: string;
  text: string;
  type: 'checkbox' | 'text' | 'number' | 'date' | 'time' | 'dropdown';
  required: boolean;
  defaultValue?: any;
  validation?: ItemValidation;
  dependencies?: ItemDependency[];
  metadata?: Record<string, any>;
  order: number;
  category?: string;
}

interface TemplateMetadata {
  version: string;
  industry: string[];
  estimatedMinutes: number;
  complianceStandards?: string[];
  attachmentTypes?: string[];
  requiresSignoff?: boolean;
  expiryDays?: number;
  recurrence?: RecurrencePattern;
}

enum TemplateCategory {
  SAFETY = 'safety',
  MAINTENANCE = 'maintenance',
  INSPECTION = 'inspection',
  INVENTORY = 'inventory',
  QUALITY = 'quality',
  ONBOARDING = 'onboarding',
  CLOSING = 'closing',
  CUSTOM = 'custom'
}
```

### PostgreSQL Template Schema
```sql
-- Template storage with versioning
CREATE TABLE list_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  category VARCHAR(50) NOT NULL,
  description TEXT,
  icon VARCHAR(50),
  visibility VARCHAR(20) DEFAULT 'personal',
  created_by UUID NOT NULL REFERENCES personnel(id),
  organization_id UUID REFERENCES organizations(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ,
  version INTEGER DEFAULT 1,
  parent_template_id UUID REFERENCES list_templates(id),
  is_active BOOLEAN DEFAULT true,
  usage_count INTEGER DEFAULT 0,
  tags TEXT[] DEFAULT '{}',
  metadata JSONB DEFAULT '{}',
  CONSTRAINT unique_template_name_per_org
    UNIQUE(organization_id, name) WHERE deleted_at IS NULL
);

-- Template items with rich field types
CREATE TABLE template_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID NOT NULL REFERENCES list_templates(id) ON DELETE CASCADE,
  text TEXT NOT NULL,
  item_type VARCHAR(20) DEFAULT 'checkbox',
  required BOOLEAN DEFAULT false,
  default_value JSONB,
  validation_rules JSONB,
  dependencies JSONB,
  metadata JSONB DEFAULT '{}',
  display_order INTEGER NOT NULL,
  category VARCHAR(100),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template usage tracking
CREATE TABLE template_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID NOT NULL REFERENCES list_templates(id),
  used_by UUID NOT NULL REFERENCES personnel(id),
  list_id UUID REFERENCES user_lists(id),
  used_at TIMESTAMPTZ DEFAULT NOW(),
  completion_time INTERVAL,
  completion_percentage DECIMAL(5,2),
  feedback_rating INTEGER CHECK (feedback_rating BETWEEN 1 AND 5),
  feedback_text TEXT
);

-- Industry-specific template library
CREATE TABLE template_library (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID NOT NULL REFERENCES list_templates(id),
  industry VARCHAR(100) NOT NULL,
  compliance_standard VARCHAR(100),
  is_certified BOOLEAN DEFAULT false,
  certification_body VARCHAR(255),
  certification_date DATE,
  expiry_date DATE,
  regulatory_references TEXT[],
  CONSTRAINT unique_industry_template
    UNIQUE(template_id, industry, compliance_standard)
);

-- Create optimized indexes
CREATE INDEX idx_templates_category ON list_templates(category) WHERE is_active = true;
CREATE INDEX idx_templates_visibility ON list_templates(visibility, organization_id);
CREATE INDEX idx_templates_search ON list_templates USING gin(
  to_tsvector('english', name || ' ' || COALESCE(description, '') || ' ' || array_to_string(tags, ' '))
);
CREATE INDEX idx_template_usage_stats ON template_usage(template_id, used_at DESC);
```

### Template Management Service
```typescript
import { SupabaseClient } from '@supabase/supabase-js';
import { z } from 'zod';

class TemplateManagementService {
  constructor(private supabase: SupabaseClient) {}

  /**
   * Create a new template with validation
   */
  async createTemplate(template: CreateTemplateDto): Promise<ListTemplate> {
    // Validate template structure
    const validationResult = this.validateTemplate(template);
    if (!validationResult.success) {
      throw new ValidationError(validationResult.errors);
    }

    // Check for duplicate names in organization
    const existing = await this.supabase
      .from('list_templates')
      .select('id')
      .eq('organization_id', template.organizationId)
      .eq('name', template.name)
      .is('deleted_at', null)
      .single();

    if (existing.data) {
      throw new ConflictError(`Template "${template.name}" already exists`);
    }

    // Create template with items in transaction
    const { data: newTemplate, error } = await this.supabase.rpc(
      'create_template_with_items',
      {
        template_data: {
          name: template.name,
          category: template.category,
          description: template.description,
          icon: template.icon,
          visibility: template.visibility,
          created_by: template.createdBy,
          organization_id: template.organizationId,
          tags: template.tags,
          metadata: template.metadata
        },
        items_data: template.items.map((item, index) => ({
          text: item.text,
          item_type: item.type,
          required: item.required,
          default_value: item.defaultValue,
          validation_rules: item.validation,
          dependencies: item.dependencies,
          metadata: item.metadata,
          display_order: index,
          category: item.category
        }))
      }
    );

    if (error) throw error;

    // Index for search
    await this.indexTemplateForSearch(newTemplate.id);

    return this.enrichTemplate(newTemplate);
  }

  /**
   * Smart template suggestions based on context
   */
  async suggestTemplates(context: SuggestionContext): Promise<ListTemplate[]> {
    const { userId, organizationId, currentTask, location, timeOfDay } = context;

    // Build smart query based on context
    const suggestions = await this.supabase.rpc('suggest_templates', {
      user_id: userId,
      org_id: organizationId,
      task_type: currentTask?.type,
      location_type: location?.type,
      time_context: this.getTimeContext(timeOfDay),
      limit: 5
    });

    // ML-based ranking (future enhancement)
    return this.rankTemplatesByRelevance(suggestions.data, context);
  }

  /**
   * Clone and customize existing template
   */
  async cloneTemplate(
    templateId: string,
    customizations: TemplateCustomization
  ): Promise<ListTemplate> {
    // Get original template with items
    const { data: original } = await this.supabase
      .from('list_templates')
      .select(`
        *,
        template_items(*)
      `)
      .eq('id', templateId)
      .single();

    if (!original) {
      throw new NotFoundError('Template not found');
    }

    // Apply customizations
    const customized = {
      ...original,
      id: undefined,
      name: customizations.name || `${original.name} (Copy)`,
      parent_template_id: templateId,
      created_at: new Date(),
      updated_at: new Date(),
      usage_count: 0,
      items: original.template_items.map(item => ({
        ...item,
        id: undefined,
        ...customizations.itemOverrides?.[item.id]
      }))
    };

    // Add/remove items as specified
    if (customizations.additionalItems) {
      customized.items.push(...customizations.additionalItems);
    }
    if (customizations.removeItemIds) {
      customized.items = customized.items.filter(
        item => !customizations.removeItemIds.includes(item.id)
      );
    }

    return this.createTemplate(customized);
  }

  /**
   * Generate template from completed list
   */
  async generateTemplateFromList(
    listId: string,
    templateConfig: GenerateTemplateConfig
  ): Promise<ListTemplate> {
    // Get completed list with statistics
    const { data: list } = await this.supabase
      .from('user_lists')
      .select(`
        *,
        list_items(*),
        list_completions(
          completion_time,
          completed_items,
          skipped_items
        )
      `)
      .eq('id', listId)
      .single();

    if (!list) {
      throw new NotFoundError('List not found');
    }

    // Analyze list patterns
    const analysis = this.analyzeListPatterns(list);

    // Generate optimized template
    const template = {
      name: templateConfig.name || `Template from ${list.name}`,
      category: this.inferCategory(list, analysis),
      description: templateConfig.description || analysis.suggestedDescription,
      items: this.optimizeTemplateItems(list.list_items, analysis),
      metadata: {
        estimatedMinutes: analysis.averageCompletionTime,
        commonSkippedItems: analysis.frequentlySkipped,
        suggestedImprovements: analysis.improvements
      }
    };

    return this.createTemplate(template);
  }

  /**
   * Smart template instantiation with context
   */
  async instantiateTemplate(
    templateId: string,
    context: InstantiationContext
  ): Promise<UserList> {
    const { data: template } = await this.supabase
      .from('list_templates')
      .select(`
        *,
        template_items(*)
      `)
      .eq('id', templateId)
      .single();

    if (!template) {
      throw new NotFoundError('Template not found');
    }

    // Apply context-aware defaults
    const items = template.template_items.map(item => ({
      text: this.interpolateText(item.text, context),
      completed: false,
      value: this.getContextualDefault(item, context),
      due_date: this.calculateDueDate(item, context),
      assigned_to: this.determineAssignee(item, context)
    }));

    // Create list from template
    const { data: newList } = await this.supabase
      .from('user_lists')
      .insert({
        name: context.listName || template.name,
        template_id: templateId,
        created_by: context.userId,
        items: items,
        metadata: {
          from_template: true,
          template_version: template.version,
          instantiation_context: context
        }
      })
      .select()
      .single();

    // Track usage
    await this.trackTemplateUsage(templateId, context.userId, newList.id);

    return newList;
  }

  /**
   * Validate template against business rules
   */
  private validateTemplate(template: any): ValidationResult {
    const schema = z.object({
      name: z.string().min(1).max(255),
      category: z.enum(Object.values(TemplateCategory) as [string, ...string[]]),
      items: z.array(z.object({
        text: z.string().min(1),
        type: z.enum(['checkbox', 'text', 'number', 'date', 'time', 'dropdown']),
        required: z.boolean().optional(),
        validation: z.object({
          pattern: z.string().optional(),
          min: z.number().optional(),
          max: z.number().optional(),
          options: z.array(z.string()).optional()
        }).optional()
      })).min(1).max(100)
    });

    return schema.safeParse(template);
  }
}
```

### Telegram Template Commands
```typescript
import { Context, InlineKeyboard } from 'grammy';

class TelegramTemplateHandler {
  /**
   * Handle template-related commands
   */
  async handleTemplateCommand(ctx: Context): Promise<void> {
    const command = ctx.message?.text?.split(' ')[0];

    switch (command) {
      case '/templates':
        await this.showTemplateCategories(ctx);
        break;
      case '/use_template':
        await this.selectTemplate(ctx);
        break;
      case '/create_template':
        await this.startTemplateCreation(ctx);
        break;
      case '/my_templates':
        await this.showUserTemplates(ctx);
        break;
    }
  }

  /**
   * Interactive template selection with categories
   */
  private async showTemplateCategories(ctx: Context): Promise<void> {
    const categories = [
      { emoji: '🦺', name: 'Safety', id: 'safety' },
      { emoji: '🔧', name: 'Maintenance', id: 'maintenance' },
      { emoji: '🔍', name: 'Inspection', id: 'inspection' },
      { emoji: '📦', name: 'Inventory', id: 'inventory' },
      { emoji: '✅', name: 'Quality', id: 'quality' },
      { emoji: '👋', name: 'Onboarding', id: 'onboarding' },
      { emoji: '🔒', name: 'Closing', id: 'closing' },
      { emoji: '⭐', name: 'Popular', id: 'popular' },
      { emoji: '🕐', name: 'Recent', id: 'recent' }
    ];

    const keyboard = new InlineKeyboard();

    // Build 3x3 grid
    for (let i = 0; i < categories.length; i += 3) {
      const row = categories.slice(i, i + 3).map(cat =>
        InlineKeyboard.text(
          `${cat.emoji} ${cat.name}`,
          `tmpl_cat:${cat.id}`
        )
      );
      keyboard.row(...row);
    }

    await ctx.reply(
      '📋 *Template Library*\n\n' +
      'Choose a category to browse templates:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Show templates in selected category
   */
  async showCategoryTemplates(ctx: Context, category: string): Promise<void> {
    const userId = ctx.from?.id;
    const templates = await this.templateService.getTemplatesByCategory(
      category,
      userId
    );

    if (templates.length === 0) {
      await ctx.reply(`No templates found in ${category} category.`);
      return;
    }

    const keyboard = new InlineKeyboard();

    templates.forEach(template => {
      keyboard.row(
        InlineKeyboard.text(
          `${template.icon} ${template.name} (${template.items.length} items)`,
          `tmpl_use:${template.id}`
        )
      );
    });

    keyboard.row(
      InlineKeyboard.text('← Back to Categories', 'tmpl_categories'),
      InlineKeyboard.text('🔍 Search', 'tmpl_search')
    );

    const categoryInfo = this.getCategoryInfo(category);

    await ctx.reply(
      `${categoryInfo.emoji} *${categoryInfo.name} Templates*\n\n` +
      `Found ${templates.length} templates:`,
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Template preview with smart instantiation
   */
  async previewTemplate(ctx: Context, templateId: string): Promise<void> {
    const template = await this.templateService.getTemplate(templateId);

    const preview = this.formatTemplatePreview(template);
    const keyboard = new InlineKeyboard()
      .row(
        InlineKeyboard.text('✅ Use This Template', `tmpl_confirm:${templateId}`),
        InlineKeyboard.text('✏️ Customize', `tmpl_customize:${templateId}`)
      )
      .row(
        InlineKeyboard.text('📊 View Stats', `tmpl_stats:${templateId}`),
        InlineKeyboard.text('← Back', 'tmpl_back')
      );

    await ctx.reply(preview, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  /**
   * Create template from conversation
   */
  async createTemplateInteractive(ctx: Context): Promise<void> {
    // Start conversational template builder
    await ctx.reply(
      '🛠 *Template Builder*\n\n' +
      "Let's create a new template! First, what should we call it?",
      { parse_mode: 'Markdown' }
    );

    // Store state for multi-step creation
    await this.stateManager.setState(ctx.from.id, {
      action: 'creating_template',
      step: 'name',
      templateData: {}
    });
  }

  /**
   * Format template for display
   */
  private formatTemplatePreview(template: ListTemplate): string {
    const stats = `📊 Used ${template.usageCount} times`;
    const time = template.metadata.estimatedMinutes
      ? `⏱ ~${template.metadata.estimatedMinutes} min`
      : '';

    const items = template.items
      .slice(0, 5)
      .map((item, i) => {
        const type = this.getItemTypeEmoji(item.type);
        const req = item.required ? '•' : '◦';
        return `${req} ${type} ${item.text}`;
      })
      .join('\n');

    const more = template.items.length > 5
      ? `\n... and ${template.items.length - 5} more items`
      : '';

    return `📋 *${template.name}*\n` +
           `${template.description}\n\n` +
           `${stats} ${time}\n\n` +
           `*Items:*\n${items}${more}\n\n` +
           `Category: ${template.category}\n` +
           `Tags: ${template.tags.join(', ')}`;
  }

  private getItemTypeEmoji(type: string): string {
    const emojis = {
      checkbox: '☑️',
      text: '📝',
      number: '🔢',
      date: '📅',
      time: '🕐',
      dropdown: '📋'
    };
    return emojis[type] || '•';
  }
}
```

### Industry-Specific Templates
```typescript
// Pre-built industry templates
const INDUSTRY_TEMPLATES = {
  construction: {
    site_safety_inspection: {
      name: 'Daily Site Safety Inspection',
      category: 'safety',
      items: [
        { text: 'PPE compliance check', type: 'checkbox', required: true },
        { text: 'Scaffolding stability verified', type: 'checkbox', required: true },
        { text: 'Fire extinguishers accessible', type: 'checkbox', required: true },
        { text: 'First aid kit stocked', type: 'checkbox', required: true },
        { text: 'Emergency exits clear', type: 'checkbox', required: true },
        { text: 'Hazardous materials secured', type: 'checkbox' },
        { text: 'Number of workers on site', type: 'number' },
        { text: 'Weather conditions', type: 'dropdown', options: ['Clear', 'Rain', 'Snow', 'Wind'] },
        { text: 'Incidents to report', type: 'text' },
        { text: 'Inspector signature', type: 'text', required: true },
        { text: 'Inspection time', type: 'time', defaultValue: 'now' }
      ],
      metadata: {
        estimatedMinutes: 15,
        complianceStandards: ['OSHA', 'ISO 45001'],
        requiresSignoff: true
      }
    }
  },

  facilities: {
    hvac_maintenance: {
      name: 'HVAC System Maintenance Checklist',
      category: 'maintenance',
      items: [
        { text: 'Check air filters', type: 'checkbox', required: true },
        { text: 'Clean condensate drain', type: 'checkbox', required: true },
        { text: 'Inspect belt tension', type: 'checkbox' },
        { text: 'Lubricate motors', type: 'checkbox' },
        { text: 'Check refrigerant levels', type: 'checkbox' },
        { text: 'Test thermostat operation', type: 'checkbox', required: true },
        { text: 'Record temperature differential', type: 'number' },
        { text: 'Check electrical connections', type: 'checkbox', required: true },
        { text: 'Clean evaporator coils', type: 'checkbox' },
        { text: 'Verify airflow', type: 'checkbox' },
        { text: 'Next service date', type: 'date' }
      ],
      metadata: {
        estimatedMinutes: 45,
        recurrence: { frequency: 'monthly', preserveTime: true }
      }
    }
  },

  retail: {
    store_opening: {
      name: 'Store Opening Checklist',
      category: 'opening',
      items: [
        { text: 'Disable alarm system', type: 'checkbox', required: true },
        { text: 'Turn on all lights', type: 'checkbox', required: true },
        { text: 'Check cash registers', type: 'checkbox', required: true },
        { text: 'Count starting cash', type: 'number', required: true },
        { text: 'Review overnight emails', type: 'checkbox' },
        { text: 'Check inventory deliveries', type: 'checkbox' },
        { text: 'Clean entrance area', type: 'checkbox' },
        { text: 'Update daily specials board', type: 'checkbox' },
        { text: 'Brief morning staff', type: 'checkbox', required: true },
        { text: 'Unlock front doors', type: 'checkbox', required: true },
        { text: 'Opening time', type: 'time', required: true }
      ],
      metadata: {
        estimatedMinutes: 30,
        recurrence: { frequency: 'daily', preserveTime: true }
      }
    }
  }
};
```

### n8n Template Workflow
```json
{
  "name": "Template Management Workflow",
  "nodes": [
    {
      "type": "n8n-nodes-base.webhook",
      "name": "Template Commands",
      "parameters": {
        "path": "templates",
        "responseMode": "lastNode",
        "options": {}
      }
    },
    {
      "type": "n8n-nodes-base.switch",
      "name": "Route Command",
      "parameters": {
        "dataType": "string",
        "value1": "={{$json.command}}",
        "rules": {
          "rules": [
            {
              "value1": "={{$json.command}}",
              "value2": "list_templates"
            },
            {
              "value1": "={{$json.command}}",
              "value2": "use_template"
            },
            {
              "value1": "={{$json.command}}",
              "value2": "create_template"
            },
            {
              "value1": "={{$json.command}}",
              "value2": "suggest_templates"
            }
          ]
        }
      }
    },
    {
      "type": "n8n-nodes-base.postgres",
      "name": "Get Templates",
      "parameters": {
        "operation": "executeQuery",
        "query": `
          SELECT
            t.*,
            json_agg(
              json_build_object(
                'id', ti.id,
                'text', ti.text,
                'type', ti.item_type,
                'required', ti.required,
                'order', ti.display_order
              ) ORDER BY ti.display_order
            ) AS items
          FROM list_templates t
          LEFT JOIN template_items ti ON t.id = ti.template_id
          WHERE t.visibility IN ('public', 'organization')
            AND t.is_active = true
            {{#if category}}
            AND t.category = '{{category}}'
            {{/if}}
          GROUP BY t.id
          ORDER BY t.usage_count DESC
          LIMIT 10
        `
      }
    },
    {
      "type": "n8n-nodes-base.function",
      "name": "Smart Suggestions",
      "parameters": {
        "functionCode": `
          // Analyze context for template suggestions
          const context = $input.item.json;

          // Time-based suggestions
          const hour = new Date().getHours();
          let timeContext = 'general';
          if (hour >= 6 && hour < 9) timeContext = 'opening';
          else if (hour >= 17 && hour < 20) timeContext = 'closing';
          else if (hour >= 9 && hour < 17) timeContext = 'operational';

          // Task-based suggestions
          const recentTasks = context.recentTasks || [];
          const taskPatterns = analyzeTaskPatterns(recentTasks);

          // Location-based suggestions
          const location = context.location;
          const locationTemplates = getLocationTemplates(location);

          // Combine and rank suggestions
          const suggestions = rankSuggestions([
            ...timeBasedTemplates[timeContext],
            ...taskPatterns.suggestedTemplates,
            ...locationTemplates
          ]);

          return {
            json: {
              suggestions: suggestions.slice(0, 5),
              context: {
                time: timeContext,
                patterns: taskPatterns,
                location: location
              }
            }
          };
        `
      }
    }
  ]
}
```

## Implementation Checklist

### Phase 1: Database Setup
- [ ] Create template tables with proper constraints
- [ ] Set up template versioning system
- [ ] Implement usage tracking tables
- [ ] Add industry template seed data

### Phase 2: Core Template Logic
- [ ] Build TemplateManagementService class
- [ ] Implement template validation
- [ ] Add template cloning functionality
- [ ] Create template generation from lists

### Phase 3: Telegram Integration
- [ ] Add template commands to bot
- [ ] Implement interactive template selection
- [ ] Build template preview system
- [ ] Add conversational template builder

### Phase 4: Smart Features
- [ ] Implement context-aware suggestions
- [ ] Add template usage analytics
- [ ] Build template optimization engine
- [ ] Create industry-specific templates

## Testing Requirements

```typescript
describe('Template System', () => {
  describe('Template Creation', () => {
    it('should validate template structure', async () => {
      const invalidTemplate = {
        name: '',
        items: []
      };

      await expect(
        templateService.createTemplate(invalidTemplate)
      ).rejects.toThrow(ValidationError);
    });

    it('should prevent duplicate template names', async () => {
      const template = createValidTemplate();
      await templateService.createTemplate(template);

      await expect(
        templateService.createTemplate(template)
      ).rejects.toThrow(ConflictError);
    });

    it('should generate template from completed list', async () => {
      const listId = 'test-list-id';
      const template = await templateService.generateTemplateFromList(listId, {
        name: 'Generated Template',
        optimizeItems: true
      });

      expect(template).toBeDefined();
      expect(template.items.length).toBeGreaterThan(0);
    });
  });

  describe('Template Usage', () => {
    it('should track template usage statistics', async () => {
      const templateId = 'test-template-id';
      const listId = await templateService.instantiateTemplate(templateId, {
        userId: 'test-user',
        context: {}
      });

      const stats = await templateService.getTemplateStats(templateId);
      expect(stats.usageCount).toBe(1);
    });

    it('should suggest relevant templates based on context', async () => {
      const suggestions = await templateService.suggestTemplates({
        timeOfDay: 'morning',
        location: { type: 'construction_site' },
        recentTasks: ['safety_check', 'equipment_inspection']
      });

      expect(suggestions[0].category).toBe('safety');
    });
  });
});
```

## Performance Specifications
- Template retrieval: < 100ms for category listing
- Template instantiation: < 200ms for 50-item template
- Search across templates: < 150ms for 1000 templates
- Suggestion generation: < 300ms with full context
- Batch template operations: 100+ templates/second

## Security Requirements
- Validate all template data against injection attacks
- Enforce visibility permissions strictly
- Audit all template modifications
- Sanitize user-generated template content
- Rate limit template creation (10 per user per day)

## Developer Resources

### Essential Documentation
```bash
# Template pattern best practices
mcp__ref__ref_search_documentation "checklist template system design patterns"

# PostgreSQL JSONB for template storage
mcp__ref__ref_search_documentation "PostgreSQL JSONB template versioning"

# Telegram inline keyboards for templates
mcp__ref__ref_search_documentation "Telegram bot inline keyboard template selection"
```

### Debugging Commands
```sql
-- Most used templates
SELECT
  t.name,
  t.category,
  COUNT(tu.id) as usage_count,
  AVG(tu.completion_percentage) as avg_completion
FROM list_templates t
JOIN template_usage tu ON t.id = tu.template_id
GROUP BY t.id
ORDER BY usage_count DESC
LIMIT 10;

-- Template performance metrics
SELECT
  template_id,
  AVG(EXTRACT(EPOCH FROM completion_time)) as avg_seconds,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY completion_percentage) as median_completion
FROM template_usage
WHERE used_at > NOW() - INTERVAL '30 days'
GROUP BY template_id;
```

## Acceptance Criteria
1. ✅ Users can browse templates by category
2. ✅ Templates can be instantiated with one command
3. ✅ System suggests relevant templates based on context
4. ✅ Templates can be created from completed lists
5. ✅ Usage statistics inform template improvements
6. ✅ Industry-specific templates available

## Notes for Developers
- Pre-load common templates for offline use
- Cache template metadata for quick browsing
- Use template versioning for backward compatibility
- Consider template marketplace for future monetization
- Implement template inheritance for variations
- Track template effectiveness through completion rates