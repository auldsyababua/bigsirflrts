# Story 4.3: List Templates System

## Overview
Implement a comprehensive template system for frequently-used lists, enabling users to quickly create standardized checklists for recurring tasks like site inspections, maintenance procedures, and safety protocols.

## Context
- **Epic**: Epic 4 - Lists Management
- **Priority**: P2 (Nice-to-have for MVP, critical for efficiency)
- **Dependencies**:
  - Story 4.1 (Lists Interface) - COMPLETED
  - Story 4.2 (List Management Commands) - COMPLETED
  - Story 1.4 (Supabase Edge Functions) - Required for template storage
- **Blocks**: None directly, enhances all list-related features

## Technical Requirements

### Core Template Architecture
```typescript
// Template data structures
interface ListTemplate {
  id: string;
  name: string;
  category: TemplateCategory;
  description: string;
  icon: string;
  items: TemplateItem[];
  metadata: TemplateMetadata;
  visibility: 'personal' | 'team' | 'organization' | 'public';
  createdBy: string;
  createdAt: Date;
  updatedAt: Date;
  usageCount: number;
  tags: string[];
}

interface TemplateItem {
  id: string;
  text: string;
  type: 'checkbox' | 'text' | 'number' | 'date' | 'time' | 'dropdown';
  required: boolean;
  defaultValue?: any;
  validation?: ItemValidation;
  dependencies?: ItemDependency[];
  metadata?: Record<string, any>;
  order: number;
  category?: string;
}

interface TemplateMetadata {
  version: string;
  industry: string[];
  estimatedMinutes: number;
  complianceStandards?: string[];
  attachmentTypes?: string[];
  requiresSignoff?: boolean;
  expiryDays?: number;
  recurrence?: RecurrencePattern;
}

enum TemplateCategory {
  SAFETY = 'safety',
  MAINTENANCE = 'maintenance',
  INSPECTION = 'inspection',
  INVENTORY = 'inventory',
  QUALITY = 'quality',
  ONBOARDING = 'onboarding',
  CLOSING = 'closing',
  CUSTOM = 'custom'
}
```

### PostgreSQL Template Schema
```sql
-- Template storage with versioning
CREATE TABLE list_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  category VARCHAR(50) NOT NULL,
  description TEXT,
  icon VARCHAR(50),
  visibility VARCHAR(20) DEFAULT 'personal',
  created_by UUID NOT NULL REFERENCES personnel(id),
  organization_id UUID REFERENCES organizations(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ,
  version INTEGER DEFAULT 1,
  parent_template_id UUID REFERENCES list_templates(id),
  is_active BOOLEAN DEFAULT true,
  usage_count INTEGER DEFAULT 0,
  tags TEXT[] DEFAULT '{}',
  metadata JSONB DEFAULT '{}',
  CONSTRAINT unique_template_name_per_org
    UNIQUE(organization_id, name) WHERE deleted_at IS NULL
);

-- Template items with rich field types
CREATE TABLE template_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID NOT NULL REFERENCES list_templates(id) ON DELETE CASCADE,
  text TEXT NOT NULL,
  item_type VARCHAR(20) DEFAULT 'checkbox',
  required BOOLEAN DEFAULT false,
  default_value JSONB,
  validation_rules JSONB,
  dependencies JSONB,
  metadata JSONB DEFAULT '{}',
  display_order INTEGER NOT NULL,
  category VARCHAR(100),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Template usage tracking
CREATE TABLE template_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID NOT NULL REFERENCES list_templates(id),
  used_by UUID NOT NULL REFERENCES personnel(id),
  list_id UUID REFERENCES user_lists(id),
  used_at TIMESTAMPTZ DEFAULT NOW(),
  completion_time INTERVAL,
  completion_percentage DECIMAL(5,2),
  feedback_rating INTEGER CHECK (feedback_rating BETWEEN 1 AND 5),
  feedback_text TEXT
);

-- Industry-specific template library
CREATE TABLE template_library (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID NOT NULL REFERENCES list_templates(id),
  industry VARCHAR(100) NOT NULL,
  compliance_standard VARCHAR(100),
  is_certified BOOLEAN DEFAULT false,
  certification_body VARCHAR(255),
  certification_date DATE,
  expiry_date DATE,
  regulatory_references TEXT[],
  CONSTRAINT unique_industry_template
    UNIQUE(template_id, industry, compliance_standard)
);

-- Create optimized indexes
CREATE INDEX idx_templates_category ON list_templates(category) WHERE is_active = true;
CREATE INDEX idx_templates_visibility ON list_templates(visibility, organization_id);
CREATE INDEX idx_templates_search ON list_templates USING gin(
  to_tsvector('english', name || ' ' || COALESCE(description, '') || ' ' || array_to_string(tags, ' '))
);
CREATE INDEX idx_template_usage_stats ON template_usage(template_id, used_at DESC);
```

### Template Management Service
```typescript
import { SupabaseClient } from '@supabase/supabase-js';
import { z } from 'zod';

class TemplateManagementService {
  constructor(private supabase: SupabaseClient) {}

  /**
   * Create a new template with validation
   */
  async createTemplate(template: CreateTemplateDto): Promise<ListTemplate> {
    // Validate template structure
    const validationResult = this.validateTemplate(template);
    if (!validationResult.success) {
      throw new ValidationError(validationResult.errors);
    }

    // Check for duplicate names in organization
    const existing = await this.supabase
      .from('list_templates')
      .select('id')
      .eq('organization_id', template.organizationId)
      .eq('name', template.name)
      .is('deleted_at', null)
      .single();

    if (existing.data) {
      throw new ConflictError(`Template "${template.name}" already exists`);
    }

    // Create template with items in transaction
    const { data: newTemplate, error } = await this.supabase.rpc(
      'create_template_with_items',
      {
        template_data: {
          name: template.name,
          category: template.category,
          description: template.description,
          icon: template.icon,
          visibility: template.visibility,
          created_by: template.createdBy,
          organization_id: template.organizationId,
          tags: template.tags,
          metadata: template.metadata
        },
        items_data: template.items.map((item, index) => ({
          text: item.text,
          item_type: item.type,
          required: item.required,
          default_value: item.defaultValue,
          validation_rules: item.validation,
          dependencies: item.dependencies,
          metadata: item.metadata,
          display_order: index,
          category: item.category
        }))
      }
    );

    if (error) throw error;

    // Index for search
    await this.indexTemplateForSearch(newTemplate.id);

    return this.enrichTemplate(newTemplate);
  }

  /**
   * Smart template suggestions based on context
   */
  async suggestTemplates(context: SuggestionContext): Promise<ListTemplate[]> {
    const { userId, organizationId, currentTask, location, timeOfDay } = context;

    // Build smart query based on context
    const suggestions = await this.supabase.rpc('suggest_templates', {
      user_id: userId,
      org_id: organizationId,
      task_type: currentTask?.type,
      location_type: location?.type,
      time_context: this.getTimeContext(timeOfDay),
      limit: 5
    });

    // ML-based ranking (future enhancement)
    return this.rankTemplatesByRelevance(suggestions.data, context);
  }

  /**
   * Clone and customize existing template
   */
  async cloneTemplate(
    templateId: string,
    customizations: TemplateCustomization
  ): Promise<ListTemplate> {
    // Get original template with items
    const { data: original } = await this.supabase
      .from('list_templates')
      .select(`
        *,
        template_items(*)
      `)
      .eq('id', templateId)
      .single();

    if (!original) {
      throw new NotFoundError('Template not found');
    }

    // Apply customizations
    const customized = {
      ...original,
      id: undefined,
      name: customizations.name || `${original.name} (Copy)`,
      parent_template_id: templateId,
      created_at: new Date(),
      updated_at: new Date(),
      usage_count: 0,
      items: original.template_items.map(item => ({
        ...item,
        id: undefined,
        ...customizations.itemOverrides?.[item.id]
      }))
    };

    // Add/remove items as specified
    if (customizations.additionalItems) {
      customized.items.push(...customizations.additionalItems);
    }
    if (customizations.removeItemIds) {
      customized.items = customized.items.filter(
        item => !customizations.removeItemIds.includes(item.id)
      );
    }

    return this.createTemplate(customized);
  }

  /**
   * Generate template from completed list
   */
  async generateTemplateFromList(
    listId: string,
    templateConfig: GenerateTemplateConfig
  ): Promise<ListTemplate> {
    // Get completed list with statistics
    const { data: list } = await this.supabase
      .from('user_lists')
      .select(`
        *,
        list_items(*),
        list_completions(
          completion_time,
          completed_items,
          skipped_items
        )
      `)
      .eq('id', listId)
      .single();

    if (!list) {
      throw new NotFoundError('List not found');
    }

    // Analyze list patterns
    const analysis = this.analyzeListPatterns(list);

    // Generate optimized template
    const template = {
      name: templateConfig.name || `Template from ${list.name}`,
      category: this.inferCategory(list, analysis),
      description: templateConfig.description || analysis.suggestedDescription,
      items: this.optimizeTemplateItems(list.list_items, analysis),
      metadata: {
        estimatedMinutes: analysis.averageCompletionTime,
        commonSkippedItems: analysis.frequentlySkipped,
        suggestedImprovements: analysis.improvements
      }
    };

    return this.createTemplate(template);
  }

  /**
   * Smart template instantiation with context
   */
  async instantiateTemplate(
    templateId: string,
    context: InstantiationContext
  ): Promise<UserList> {
    const { data: template } = await this.supabase
      .from('list_templates')
      .select(`
        *,
        template_items(*)
      `)
      .eq('id', templateId)
      .single();

    if (!template) {
      throw new NotFoundError('Template not found');
    }

    // Apply context-aware defaults
    const items = template.template_items.map(item => ({
      text: this.interpolateText(item.text, context),
      completed: false,
      value: this.getContextualDefault(item, context),
      due_date: this.calculateDueDate(item, context),
      assigned_to: this.determineAssignee(item, context)
    }));

    // Create list from template
    const { data: newList } = await this.supabase
      .from('user_lists')
      .insert({
        name: context.listName || template.name,
        template_id: templateId,
        created_by: context.userId,
        items: items,
        metadata: {
          from_template: true,
          template_version: template.version,
          instantiation_context: context
        }
      })
      .select()
      .single();

    // Track usage
    await this.trackTemplateUsage(templateId, context.userId, newList.id);

    return newList;
  }

  /**
   * Validate template against business rules
   */
  private validateTemplate(template: any): ValidationResult {
    const schema = z.object({
      name: z.string().min(1).max(255),
      category: z.enum(Object.values(TemplateCategory) as [string, ...string[]]),
      items: z.array(z.object({
        text: z.string().min(1),
        type: z.enum(['checkbox', 'text', 'number', 'date', 'time', 'dropdown']),
        required: z.boolean().optional(),
        validation: z.object({
          pattern: z.string().optional(),
          min: z.number().optional(),
          max: z.number().optional(),
          options: z.array(z.string()).optional()
        }).optional()
      })).min(1).max(100)
    });

    return schema.safeParse(template);
  }
}
```

### Telegram Template Commands
```typescript
import { Context, InlineKeyboard } from 'grammy';

class TelegramTemplateHandler {
  /**
   * Handle template-related commands
   */
  async handleTemplateCommand(ctx: Context): Promise<void> {
    const command = ctx.message?.text?.split(' ')[0];

    switch (command) {
      case '/templates':
        await this.showTemplateCategories(ctx);
        break;
      case '/use_template':
        await this.selectTemplate(ctx);
        break;
      case '/create_template':
        await this.startTemplateCreation(ctx);
        break;
      case '/my_templates':
        await this.showUserTemplates(ctx);
        break;
    }
  }

  /**
   * Interactive template selection with categories
   */
  private async showTemplateCategories(ctx: Context): Promise<void> {
    const categories = [
      { emoji: 'ü¶∫', name: 'Safety', id: 'safety' },
      { emoji: 'üîß', name: 'Maintenance', id: 'maintenance' },
      { emoji: 'üîç', name: 'Inspection', id: 'inspection' },
      { emoji: 'üì¶', name: 'Inventory', id: 'inventory' },
      { emoji: '‚úÖ', name: 'Quality', id: 'quality' },
      { emoji: 'üëã', name: 'Onboarding', id: 'onboarding' },
      { emoji: 'üîí', name: 'Closing', id: 'closing' },
      { emoji: '‚≠ê', name: 'Popular', id: 'popular' },
      { emoji: 'üïê', name: 'Recent', id: 'recent' }
    ];

    const keyboard = new InlineKeyboard();

    // Build 3x3 grid
    for (let i = 0; i < categories.length; i += 3) {
      const row = categories.slice(i, i + 3).map(cat =>
        InlineKeyboard.text(
          `${cat.emoji} ${cat.name}`,
          `tmpl_cat:${cat.id}`
        )
      );
      keyboard.row(...row);
    }

    await ctx.reply(
      'üìã *Template Library*\n\n' +
      'Choose a category to browse templates:',
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Show templates in selected category
   */
  async showCategoryTemplates(ctx: Context, category: string): Promise<void> {
    const userId = ctx.from?.id;
    const templates = await this.templateService.getTemplatesByCategory(
      category,
      userId
    );

    if (templates.length === 0) {
      await ctx.reply(`No templates found in ${category} category.`);
      return;
    }

    const keyboard = new InlineKeyboard();

    templates.forEach(template => {
      keyboard.row(
        InlineKeyboard.text(
          `${template.icon} ${template.name} (${template.items.length} items)`,
          `tmpl_use:${template.id}`
        )
      );
    });

    keyboard.row(
      InlineKeyboard.text('‚Üê Back to Categories', 'tmpl_categories'),
      InlineKeyboard.text('üîç Search', 'tmpl_search')
    );

    const categoryInfo = this.getCategoryInfo(category);

    await ctx.reply(
      `${categoryInfo.emoji} *${categoryInfo.name} Templates*\n\n` +
      `Found ${templates.length} templates:`,
      {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      }
    );
  }

  /**
   * Template preview with smart instantiation
   */
  async previewTemplate(ctx: Context, templateId: string): Promise<void> {
    const template = await this.templateService.getTemplate(templateId);

    const preview = this.formatTemplatePreview(template);
    const keyboard = new InlineKeyboard()
      .row(
        InlineKeyboard.text('‚úÖ Use This Template', `tmpl_confirm:${templateId}`),
        InlineKeyboard.text('‚úèÔ∏è Customize', `tmpl_customize:${templateId}`)
      )
      .row(
        InlineKeyboard.text('üìä View Stats', `tmpl_stats:${templateId}`),
        InlineKeyboard.text('‚Üê Back', 'tmpl_back')
      );

    await ctx.reply(preview, {
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  /**
   * Create template from conversation
   */
  async createTemplateInteractive(ctx: Context): Promise<void> {
    // Start conversational template builder
    await ctx.reply(
      'üõ† *Template Builder*\n\n' +
      "Let's create a new template! First, what should we call it?",
      { parse_mode: 'Markdown' }
    );

    // Store state for multi-step creation
    await this.stateManager.setState(ctx.from.id, {
      action: 'creating_template',
      step: 'name',
      templateData: {}
    });
  }

  /**
   * Format template for display
   */
  private formatTemplatePreview(template: ListTemplate): string {
    const stats = `üìä Used ${template.usageCount} times`;
    const time = template.metadata.estimatedMinutes
      ? `‚è± ~${template.metadata.estimatedMinutes} min`
      : '';

    const items = template.items
      .slice(0, 5)
      .map((item, i) => {
        const type = this.getItemTypeEmoji(item.type);
        const req = item.required ? '‚Ä¢' : '‚ó¶';
        return `${req} ${type} ${item.text}`;
      })
      .join('\n');

    const more = template.items.length > 5
      ? `\n... and ${template.items.length - 5} more items`
      : '';

    return `üìã *${template.name}*\n` +
           `${template.description}\n\n` +
           `${stats} ${time}\n\n` +
           `*Items:*\n${items}${more}\n\n` +
           `Category: ${template.category}\n` +
           `Tags: ${template.tags.join(', ')}`;
  }

  private getItemTypeEmoji(type: string): string {
    const emojis = {
      checkbox: '‚òëÔ∏è',
      text: 'üìù',
      number: 'üî¢',
      date: 'üìÖ',
      time: 'üïê',
      dropdown: 'üìã'
    };
    return emojis[type] || '‚Ä¢';
  }
}
```

### Industry-Specific Templates
```typescript
// Pre-built industry templates
const INDUSTRY_TEMPLATES = {
  construction: {
    site_safety_inspection: {
      name: 'Daily Site Safety Inspection',
      category: 'safety',
      items: [
        { text: 'PPE compliance check', type: 'checkbox', required: true },
        { text: 'Scaffolding stability verified', type: 'checkbox', required: true },
        { text: 'Fire extinguishers accessible', type: 'checkbox', required: true },
        { text: 'First aid kit stocked', type: 'checkbox', required: true },
        { text: 'Emergency exits clear', type: 'checkbox', required: true },
        { text: 'Hazardous materials secured', type: 'checkbox' },
        { text: 'Number of workers on site', type: 'number' },
        { text: 'Weather conditions', type: 'dropdown', options: ['Clear', 'Rain', 'Snow', 'Wind'] },
        { text: 'Incidents to report', type: 'text' },
        { text: 'Inspector signature', type: 'text', required: true },
        { text: 'Inspection time', type: 'time', defaultValue: 'now' }
      ],
      metadata: {
        estimatedMinutes: 15,
        complianceStandards: ['OSHA', 'ISO 45001'],
        requiresSignoff: true
      }
    }
  },

  facilities: {
    hvac_maintenance: {
      name: 'HVAC System Maintenance Checklist',
      category: 'maintenance',
      items: [
        { text: 'Check air filters', type: 'checkbox', required: true },
        { text: 'Clean condensate drain', type: 'checkbox', required: true },
        { text: 'Inspect belt tension', type: 'checkbox' },
        { text: 'Lubricate motors', type: 'checkbox' },
        { text: 'Check refrigerant levels', type: 'checkbox' },
        { text: 'Test thermostat operation', type: 'checkbox', required: true },
        { text: 'Record temperature differential', type: 'number' },
        { text: 'Check electrical connections', type: 'checkbox', required: true },
        { text: 'Clean evaporator coils', type: 'checkbox' },
        { text: 'Verify airflow', type: 'checkbox' },
        { text: 'Next service date', type: 'date' }
      ],
      metadata: {
        estimatedMinutes: 45,
        recurrence: { frequency: 'monthly', preserveTime: true }
      }
    }
  },

  retail: {
    store_opening: {
      name: 'Store Opening Checklist',
      category: 'opening',
      items: [
        { text: 'Disable alarm system', type: 'checkbox', required: true },
        { text: 'Turn on all lights', type: 'checkbox', required: true },
        { text: 'Check cash registers', type: 'checkbox', required: true },
        { text: 'Count starting cash', type: 'number', required: true },
        { text: 'Review overnight emails', type: 'checkbox' },
        { text: 'Check inventory deliveries', type: 'checkbox' },
        { text: 'Clean entrance area', type: 'checkbox' },
        { text: 'Update daily specials board', type: 'checkbox' },
        { text: 'Brief morning staff', type: 'checkbox', required: true },
        { text: 'Unlock front doors', type: 'checkbox', required: true },
        { text: 'Opening time', type: 'time', required: true }
      ],
      metadata: {
        estimatedMinutes: 30,
        recurrence: { frequency: 'daily', preserveTime: true }
      }
    }
  }
};
```

### n8n Template Workflow
```json
{
  "name": "Template Management Workflow",
  "nodes": [
    {
      "type": "n8n-nodes-base.webhook",
      "name": "Template Commands",
      "parameters": {
        "path": "templates",
        "responseMode": "lastNode",
        "options": {}
      }
    },
    {
      "type": "n8n-nodes-base.switch",
      "name": "Route Command",
      "parameters": {
        "dataType": "string",
        "value1": "={{$json.command}}",
        "rules": {
          "rules": [
            {
              "value1": "={{$json.command}}",
              "value2": "list_templates"
            },
            {
              "value1": "={{$json.command}}",
              "value2": "use_template"
            },
            {
              "value1": "={{$json.command}}",
              "value2": "create_template"
            },
            {
              "value1": "={{$json.command}}",
              "value2": "suggest_templates"
            }
          ]
        }
      }
    },
    {
      "type": "n8n-nodes-base.postgres",
      "name": "Get Templates",
      "parameters": {
        "operation": "executeQuery",
        "query": `
          SELECT
            t.*,
            json_agg(
              json_build_object(
                'id', ti.id,
                'text', ti.text,
                'type', ti.item_type,
                'required', ti.required,
                'order', ti.display_order
              ) ORDER BY ti.display_order
            ) AS items
          FROM list_templates t
          LEFT JOIN template_items ti ON t.id = ti.template_id
          WHERE t.visibility IN ('public', 'organization')
            AND t.is_active = true
            {{#if category}}
            AND t.category = '{{category}}'
            {{/if}}
          GROUP BY t.id
          ORDER BY t.usage_count DESC
          LIMIT 10
        `
      }
    },
    {
      "type": "n8n-nodes-base.function",
      "name": "Smart Suggestions",
      "parameters": {
        "functionCode": `
          // Analyze context for template suggestions
          const context = $input.item.json;

          // Time-based suggestions
          const hour = new Date().getHours();
          let timeContext = 'general';
          if (hour >= 6 && hour < 9) timeContext = 'opening';
          else if (hour >= 17 && hour < 20) timeContext = 'closing';
          else if (hour >= 9 && hour < 17) timeContext = 'operational';

          // Task-based suggestions
          const recentTasks = context.recentTasks || [];
          const taskPatterns = analyzeTaskPatterns(recentTasks);

          // Location-based suggestions
          const location = context.location;
          const locationTemplates = getLocationTemplates(location);

          // Combine and rank suggestions
          const suggestions = rankSuggestions([
            ...timeBasedTemplates[timeContext],
            ...taskPatterns.suggestedTemplates,
            ...locationTemplates
          ]);

          return {
            json: {
              suggestions: suggestions.slice(0, 5),
              context: {
                time: timeContext,
                patterns: taskPatterns,
                location: location
              }
            }
          };
        `
      }
    }
  ]
}
```

## Implementation Checklist

### Phase 1: Database Setup
- [ ] Create template tables with proper constraints
- [ ] Set up template versioning system
- [ ] Implement usage tracking tables
- [ ] Add industry template seed data

### Phase 2: Core Template Logic
- [ ] Build TemplateManagementService class
- [ ] Implement template validation
- [ ] Add template cloning functionality
- [ ] Create template generation from lists

### Phase 3: Telegram Integration
- [ ] Add template commands to bot
- [ ] Implement interactive template selection
- [ ] Build template preview system
- [ ] Add conversational template builder

### Phase 4: Smart Features
- [ ] Implement context-aware suggestions
- [ ] Add template usage analytics
- [ ] Build template optimization engine
- [ ] Create industry-specific templates

## Testing Requirements

```typescript
describe('Template System', () => {
  describe('Template Creation', () => {
    it('should validate template structure', async () => {
      const invalidTemplate = {
        name: '',
        items: []
      };

      await expect(
        templateService.createTemplate(invalidTemplate)
      ).rejects.toThrow(ValidationError);
    });

    it('should prevent duplicate template names', async () => {
      const template = createValidTemplate();
      await templateService.createTemplate(template);

      await expect(
        templateService.createTemplate(template)
      ).rejects.toThrow(ConflictError);
    });

    it('should generate template from completed list', async () => {
      const listId = 'test-list-id';
      const template = await templateService.generateTemplateFromList(listId, {
        name: 'Generated Template',
        optimizeItems: true
      });

      expect(template).toBeDefined();
      expect(template.items.length).toBeGreaterThan(0);
    });
  });

  describe('Template Usage', () => {
    it('should track template usage statistics', async () => {
      const templateId = 'test-template-id';
      const listId = await templateService.instantiateTemplate(templateId, {
        userId: 'test-user',
        context: {}
      });

      const stats = await templateService.getTemplateStats(templateId);
      expect(stats.usageCount).toBe(1);
    });

    it('should suggest relevant templates based on context', async () => {
      const suggestions = await templateService.suggestTemplates({
        timeOfDay: 'morning',
        location: { type: 'construction_site' },
        recentTasks: ['safety_check', 'equipment_inspection']
      });

      expect(suggestions[0].category).toBe('safety');
    });
  });
});
```

## Performance Specifications
- Template retrieval: < 100ms for category listing
- Template instantiation: < 200ms for 50-item template
- Search across templates: < 150ms for 1000 templates
- Suggestion generation: < 300ms with full context
- Batch template operations: 100+ templates/second

## Security Requirements
- Validate all template data against injection attacks
- Enforce visibility permissions strictly
- Audit all template modifications
- Sanitize user-generated template content
- Rate limit template creation (10 per user per day)

## Developer Resources

### Essential Documentation
```bash
# Template pattern best practices
mcp__ref__ref_search_documentation "checklist template system design patterns"

# PostgreSQL JSONB for template storage
mcp__ref__ref_search_documentation "PostgreSQL JSONB template versioning"

# Telegram inline keyboards for templates
mcp__ref__ref_search_documentation "Telegram bot inline keyboard template selection"
```

### Debugging Commands
```sql
-- Most used templates
SELECT
  t.name,
  t.category,
  COUNT(tu.id) as usage_count,
  AVG(tu.completion_percentage) as avg_completion
FROM list_templates t
JOIN template_usage tu ON t.id = tu.template_id
GROUP BY t.id
ORDER BY usage_count DESC
LIMIT 10;

-- Template performance metrics
SELECT
  template_id,
  AVG(EXTRACT(EPOCH FROM completion_time)) as avg_seconds,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY completion_percentage) as median_completion
FROM template_usage
WHERE used_at > NOW() - INTERVAL '30 days'
GROUP BY template_id;
```

## Acceptance Criteria
1. ‚úÖ Users can browse templates by category
2. ‚úÖ Templates can be instantiated with one command
3. ‚úÖ System suggests relevant templates based on context
4. ‚úÖ Templates can be created from completed lists
5. ‚úÖ Usage statistics inform template improvements
6. ‚úÖ Industry-specific templates available

## Notes for Developers
- Pre-load common templates for offline use
- Cache template metadata for quick browsing
- Use template versioning for backward compatibility
- Consider template marketplace for future monetization
- Implement template inheritance for variations
- Track template effectiveness through completion rates